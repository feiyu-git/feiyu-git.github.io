(window.webpackJsonp=window.webpackJsonp||[]).push([["technology"],{"0229":function(t,e){t.exports=""},"04aa":function(t,e){t.exports='<h1 id="扩展运算符">扩展运算符</h1> <h5 id="关于扩展运算符">关于扩展运算符</h5> <p>深拷贝和浅拷贝</p> <p>拓展运算符在数据<strong>分解</strong>的时候只会<strong>分解</strong>第一层的数据而不会分解其内部的元素。【即拓展运算符属于浅拷贝】</p> <pre><code class="language-javascript">//浅拷贝是指普通的赋值，对于一般复杂的数据类型，如一个对象下的一个的对象，如果只是变通的赋值，则不会完全拷贝下来，如果改变其中的值，则另一个也会发生改变\n\n//利用扩展运算符我们可以进行深拷贝\n\n```\n\n扩展运算符可以当做连接运算符进行使用\n```\nlet arr=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]\nlet arr_two=[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]\n//一般我们会采用concat方式将两个数组进行连接，但是扩展运算符也可以做到\nlet newarr=[...arr,...arr_two]\n//还有一种写法\nlet new_arr=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,...arr_two,&#39;e&#39;]\n```\n可以字符串转数组\n```\nlet str=&quot;hellow world&quot;\nlet arr=[...str]\n```\n百度上说可以有在Math.max方法中\n```\nlet arr=[1,2,5,6,7]\nMath.max(...arr)\n//初步了解apply和call方法，两个方法都是传入数组\n\n```\n\n#map方法\nmap方法有三个参数，分别为值，下标，和运用其方法的数组\n其中值是必需的其它两项看需求\nmap方法是逐个来改变数组的元素值\n```\nlet arr=[1,2,5,6,7]\narr.map((item,index,arr)=&gt;{\nreturn item*=10\n})\n```\n\n#from方法\n```\n初步了解是将一个字符串转化为数组\n```</code></pre> '},"0a9a":function(t,e){t.exports='<h1 id="vue-自定义组件-v-model双向绑定、-父子组件同步通信父子双向绑定">vue 自定义组件 v-model双向绑定、 父子组件同步通信(父子双向绑定)</h1> <p>参考文档：<a href="https://www.cnblogs.com/gsgs/p/7294160.html">https://www.cnblogs.com/gsgs/p/7294160.html</a></p> <h5 id="父子组件通信，都是单向的，很多时候需要双向通信。方法如下：">父子组件通信，都是单向的，很多时候需要双向通信。方法如下：</h5> <p>　　1、父组件使用：msg.sync=&quot;aa&quot; 子组件使用$emit(&#39;update:msg&#39;, &#39;msg改变后的值xxx&#39;) </p> <p>　　2、父组件传值直接传对象，子组件收到对象后可随意改变对象的属性，但不能改变对象本身。</p> <p>　　3、父组件使用： v-model </p> <p>　　第一种曾经被废除过，由于维护成本的原因被删掉，但经过证实，确实有存在的意义，又被加上。</p> <h5 id="第一种、sync方式">第一种、sync方式</h5> <pre><code class="language-javascript">// 父组件：\n    &lt;template&gt;\n  &lt;div&gt;\n    &lt;aa class=&quot;abc&quot; :snycTest.sync=&quot;test&quot; &gt;&lt;/aa&gt;\n      {{&#39;父组件：&#39; + test}}\n    &lt;button @click=&quot;fn&quot;&gt;\n      外面改变里面\n    &lt;/button&gt;\n\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport aa from &#39;./test.vue&#39;\n  export default {\n    data () {\n      return {\n        test: &#39;&#39;\n      }\n    },\n    methods: {\n      fn () {\n        this.test += 1\n      }\n    },\n    components:{\n      aa\n    }\n  }\n&lt;/script&gt;\n\n// 子组件：\n &lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li&gt;{{&#39;子组件：&#39;+ snycTest}}&lt;/li&gt;\n      &lt;button @click=&quot;fn2&quot;&gt;里面改变外面&lt;/button&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    props: {\n      snycTest: &#39;&#39;\n    },\n    methods: {\n      fn2 () {\n        this.$emit(&#39;update:snycTest&#39;, this.snycTest+1) //这儿是关键 update:snycTest 自定义事件会告诉父组件将父组件的 test值改为this.snycTest+1，并传回给子组件。\n        } \n    } \n} \n&lt;/script&gt;</code></pre> <h5 id="第二种、v-model方式">第二种、v-model方式</h5> <pre><code class="language-javascript">// 父组件：\n &lt;template&gt;\n  &lt;div&gt;\n    &lt;aa class=&quot;abc&quot; v-model=&quot;test&quot; &gt;&lt;/aa&gt;  // 组件中使用v-model\n      {{&#39;外面的值：&#39; + test}} // 这儿试验test与内部msg值为双向绑定关系\n    &lt;button @click=&quot;fn&quot;&gt;\n      外面改变里面\n    &lt;/button&gt;\n\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport aa from &#39;./test.vue&#39;\n  export default {\n    data () {\n      return {\n        test: &#39;&#39;\n      }\n    },\n    methods: {\n      fn () {\n        this.test += 1 \n      }\n    },\n    components:{\n      aa\n    }\n  }\n&lt;/script&gt;\n\n// 子组件写法一：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li&gt;{{&#39;里面的值：&#39;+ msg}}&lt;/li&gt;\n      &lt;button @click=&quot;fn2&quot;&gt;里面改变外面&lt;/button&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    model: {    // 使用model， 这儿2个属性，prop属性说，我要将msg作为该组件被使用时（此处为aa组件被父组件调用）v-model能取到的值，event说，我emit ‘cc’ 的时候，参数的值就是父组件v-model收到的值。\n      prop: &#39;msg&#39;,\n      event: &#39;cc&#39;\n    },\n    props: {\n      msg: &#39;&#39;\n    },\n    methods: {\n      fn2 () {\n        this.$emit(&#39;cc&#39;, this.msg+2)\n      }\n    }\n  }\n&lt;/script&gt;\n\n//  子组件写法二：\n&lt;template&gt;\n &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li&gt;{{&#39;里面的值：&#39;+ value}}&lt;/li&gt; // 组件使用时有v-model属性，value初始传的‘what’ 不会被渲染，而是v-model绑定的test值被渲染，这儿value会被重新赋值为v-model绑定的test的值。\n      &lt;button @click=&quot;fn2&quot;&gt;里面改变外面&lt;/button&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    props: {\n      value: { // 必须要使用value\n　　　　　default: &#39;&#39;,\n　　　　},\n    },\n\n    methods: {\n      fn2 () {\n        this.$emit(&#39;input&#39;, this.value+2) // 这儿必须用input 发送数据，发送的数据会被父级v-model=“test”接受到，再被value=test传回来。\n      }\n    }\n  }\n&lt;/script&gt;</code></pre> '},"0cf0":function(t,e){t.exports='<h1 id="关于input中的checked属性">关于input中的checked属性</h1> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-6e628d42b4fa30a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-47b271fdbed94a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> '},1017:function(t,e){t.exports='<h3 id="关于-vue-中的父子传值">关于 VUE 中的父子传值</h3> <p>​ 父子传值是涉及到有父子组件关系传值，不是路由跳转，路由跳转需要用到动态路由传参。</p> <h5 id="1、子传父：">1、子传父：</h5> <p>​ 1》、可以通过 this.$emit( &quot;toFather&quot;,sondata ) 进行传递，通过事件触发，或者是放在钩子函数中。</p> <p>​ 2》、父元素在标签中自定义一个事件来接收子元素传过来的数据，事件属性名是 toFather </p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-e435bf45af55c90f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>子传父：子组件的值与父元素的值也可以实时绑定的，只要子组件的值在发生变化时能及时将新值传给父组件</p> <h5 id="2、父传子：">2、父传子：</h5> <p>​ 父组件传值</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-42ac02e319753ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>​ 子组件接收</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-8948462af1413b59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>父传子：子组件中 props 的值是与父元素的值是实时关联的，即父组件对应的值发生变化，子组件对应的值也发生变化。但是，如果在 created 中将 props 中的这个值赋给一个变量，那么这个变量的值只会变化一次，因为created只会执行一次。因此可以用监听。</p> '},"14c3":function(t,e,n){var o=n("c6b6"),a=n("9263");t.exports=function(t,e){var n=t.exec;if("function"==typeof n){var i=n.call(t,e);if("object"!=typeof i)throw TypeError("RegExp exec method returned something other than an Object or null");return i}if("RegExp"!==o(t))throw TypeError("RegExp#exec called on incompatible receiver");return a.call(t,e)}},"159b":function(t,e,n){var o=n("da84"),a=n("fdbc"),i=n("17c2"),r=n("9112");for(var s in a){var l=o[s],p=l&&l.prototype;if(p&&p.forEach!==i)try{r(p,"forEach",i)}catch(t){p.forEach=i}}},"17c2":function(t,e,n){"use strict";var o=n("b727").forEach,a=n("a640"),i=n("ae40"),r=a("forEach"),s=i("forEach");t.exports=r&&s?[].forEach:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}},"19b4":function(t,e){t.exports='<h3 id="如何创建一个新项目">如何创建一个新项目</h3> <p>1、安装 node.js</p> <p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p> <p>2、安装 VSCODE</p> <p>3、全局安装脚手架【在 cmd 运行命令】npm install -g @vue/cli</p> <pre><code>npm install -g @vue/cli</code></pre><p>4、新建一个文件夹</p> <p>5、创建一个项目【在命令行窗口】</p> <pre><code class="language-html">vue create name【 name为文件名--》不允许有大写字母和中文 】</code></pre> <p>两种模式一般选择默认模式</p> <p>6、运行项目</p> <pre><code class="language-html">npm run serve</code></pre> <p>在命令行输入【 cd demo-test 切换到制定文件夹（demo-test是文件名） 】</p> '},"1abb":function(t,e){t.exports='<h3 id="关于-vant-组件自动按需引入问题">关于 vant 组件自动按需引入问题</h3> <h5 id="1、安装插件">1、安装插件</h5> <pre><code>npm i vant -S\n# 安装插件\nnpm i babel-plugin-import -D</code></pre><h5 id="2、babelconfigjs-配置">2、babel.config.js 配置</h5> <p>​ 配置完成后会自动引入 css 样式（不配置直接使用组件后会发现没有 css 样式）</p> <pre><code class="language-vue">// 对于使用 babel7 的用户，可以在 babel.config.js 中配置\nmodule.exports = {\n  plugins: [\n    [&#39;import&#39;, {\n      libraryName: &#39;vant&#39;,\n      libraryDirectory: &#39;es&#39;,\n      style: true\n    }, &#39;vant&#39;]\n  ]\n};\n// 接着你可以在代码中直接引入 Vant 组件\n// 插件会自动将代码转化为方式二中的按需引入形式</code></pre> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-53aa561c290c29de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="3、专门建一个文件引入、使用组件">3、专门建一个文件引入、使用组件</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-fe7bf4f37f79df1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="4、在-minjs-引入存放-vant-组件的文件">4、在 min.js 引入存放 vant 组件的文件</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-2c03e596235cfc4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="5、完成以上步骤就可以使用组件了">5、完成以上步骤就可以使用组件了</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-bc077a7cdc853090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="6、效果">6、效果</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-935acc4960d11e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> '},"1b04":function(t,e){t.exports='<h3 id="vue----中子组件触发父组件的方法">vue 中子组件触发父组件的方法</h3> <h5 id="1、在子组件调用父件组中的方法：">1、在子组件调用父件组中的方法：</h5> <h5 id="方法一：">方法一：</h5> <p>​ 子组件写法：</p> <pre><code class="language-js">&lt;template&gt;\n   &lt;div&gt;\n       &lt;span&gt;子组件&lt;/span&gt;\n       &lt;button @click=&quot;trigger&quot;&gt;子组件按钮11&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    methods: {\n        trigger(){\n            this.$parent.fathers(33333)        // 调用父组件的方法并传值\n        }\n    }\n}\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;</code></pre> <p>​ 父组件写法：</p> <pre><code class="language-js">&lt;template&gt;\n   &lt;div&gt;\n       &lt;div class=&quot;father&quot;&gt;\n              &lt;span&gt;电影模块&lt;/span&gt;\n              &lt;button @click=&quot;fathers&quot;&gt;父组件按钮11&lt;/button&gt;  // 该点击事件可以不写，通过子组件触发\n       &lt;/div&gt;\n       &lt;List&gt;&lt;/List&gt;        // 引入的子组件\n   &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport List from &#39;./children/List&#39;\nexport default {\n    components:{\n        List\n    },\n    methods: {\n        fathers(){\n            alert(9999999)\n        }\n    }\n}\n&lt;/script&gt;</code></pre> <h5 id="方法二：">方法二：</h5> <p>​ 子组件写法：</p> <pre><code class="language-js">&lt;template&gt;\n   &lt;div&gt;\n       &lt;span&gt;子组件&lt;/span&gt;\n       &lt;button @click=&quot;trigger&quot;&gt;子组件按钮11&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    methods: {\n        trigger(){\n            this.$emit(&quot;sonMethods&quot;)\n        }\n    }\n}\n&lt;/script&gt;</code></pre> <p>​ 父组件写法：</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-61cad55066ff40a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="方法三：把父组件中的方法传到子组件中取，在子组件中调用该方法">方法三：把父组件中的方法传到子组件中取，在子组件中调用该方法</h5> <p>​ 父组件写法：</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-0acaffad896eb21e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>​ 子元素的写法：</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-0fd7766b71be9b0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="2、在父组件调用子件组中的方法：">2、在父组件调用子件组中的方法：</h5> <p>​ 子组件：</p> <pre><code class="language-js">&lt;template&gt;\n   &lt;div&gt;\n       &lt;span&gt;子组件&lt;/span&gt;\n       &lt;button &gt;子组件按钮11&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    methods: {\n        trigger(){\n            alert(666666666)\n        }\n    }\n}\n&lt;/script&gt;</code></pre> <p>​ 父组件：</p> <p>​ 我们都知道通过$ref可以获取到某个DOM，但是它也可以用来获取子组件的实例，调用子组件的方法</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-a70bccee7aaf7675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> '},"1bf9":function(t,e){t.exports='<p>JSONP 跨域</p> <p>1、前端代码</p> <pre><code class="language-javascript">&lt;script&gt;\n        var script = document.createElement(&quot;script&quot;)\n        script.src = &quot;http://localhost:8888?callback=getData&quot;\n        document.body.appendChild(script)\n\n        function getData(res) {\n            console.log(res)\n        }\n&lt;/script&gt;</code></pre> <p>2、用koa启一个服务</p> <pre><code class="language-javascript">const Koa = require(&quot;koa&quot;)\n\nconst app = new Koa()\n\napp.use((ctx) =&gt; {\n    // 接收前端传过来的参数\n    let callback = ctx.query.callback\n    let data = {\n        code:666,\n        msg:&quot;success&quot;,\n        data:{\n            username:&quot;laohu&quot;,\n            age:100\n        }\n    }\n    let dataStr = JSON.stringify(data)\n    let res = callback + &quot;(&quot; + dataStr + &quot;)&quot;\n    // 返回给前端的数据\n    ctx.body = res\n})\n\napp.listen(8888, () =&gt; {\n    console.log(&quot;http://localhost:8888&quot;)\n})</code></pre> '},"20e4":function(t,e){t.exports='<h1 id="promiseall">Promise.all</h1> <p>Promise.all的使用</p> <pre><code class="language-javascript">&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    let p1 = axios.get(&quot;http://132.232.94.151:3000/api/film/getList&quot;)\n    let p2 = axios.get(&quot;http://132.232.94.151:3000/api/city/getList&quot;)\n    let p3 = axios.get(&quot;http://132.232.94.151:3000/api/film/getList1111&quot;)\n    Promise.all([p1,p2,p3]).then(res =&gt; {\n        console.log(res)\n    }).catch(err =&gt; {\n        console.log(err)\n    })\n\n&lt;/script&gt;</code></pre> '},"21ff":function(t,e){t.exports='<h3 id="卖座后台管理系统小知识点">卖座后台管理系统小知识点</h3> <h5 id="1、终止函数继续向后执行的方法">1、终止函数继续向后执行的方法</h5> <p>也可以组合 || &amp;&amp; 使用</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-4cca3654be88786d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="2、页面-loading-的使用">2、页面 loading 的使用</h5> <ul> <li>页面加载的 loading : 用标签属性来控制</li> </ul> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-d98818dd3f559763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <ul> <li><p>小的 loading 用在提交时在按钮处显示</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-36a20e645b69e051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> </li> </ul> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-88bd740fd33dd52f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <ul> <li>饿了么利用【 指令方式 】控制 loading 的显示与隐藏</li> </ul> <pre><code class="language-js">// 可以用在页面跳转进入页面时的 loading \n// 把这个 loading 赋值给一个变量\nconst loading = this.$loading({\n    lock: true,\n    text: &#39;Loading&#39;,\n    spinner: &#39;el-icon-loading&#39;,\n    background: &#39;rgba(0, 0, 0, 0.7)&#39;\n});\n// 在需要结束 loading 的地方用下面的方式来结束\n    loading.close();</code></pre> <h5 id="3、promise-的-finally-属性">3、promise 的 finally 属性</h5> <p>​ 不管请求是发送成功还是失败，都会调用 finally 属性，可用来结束页面 loading</p> <pre><code>不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/18620107-5d270552ee79b088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="4、get-请求写法问题">4、get 请求写法问题</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-b69b64a72f72e269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="5、promiseall">5、Promise.all</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-3d016d8986a903cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-7570ae3db1e83e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <ol start="6"> <li><h5 id="饿了么-ui-样式覆盖方法">饿了么 ui 样式覆盖方法</h5> </li> </ol> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-0b2dfd15fde2b73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="7、服务器启动命令">7、服务器启动命令</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-56a57791e3ac5150.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="8、路由守卫">8、路由守卫</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-5a1edd684d6a5742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="9、vuex--的-mapstate--mapgetters-方法">9、vuex 的 mapState / mapGetters 方法</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-b464dd653ffd2432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="10、vue-的-update-属性">10、vue 的 update 属性</h5> <h5 id="11、父子组件双向绑定传参">11、父子组件双向绑定传参</h5> <h5 id="12、数组最常用的方法">12、数组最常用的方法</h5> <pre><code>map / filter / find / foreach / splice</code></pre><h5 id="13、路由的-from-与-to属性">13、路由的 from 与 to属性</h5> <h5 id="14、两层-v-for-循环用法">14、两层 v-for 循环用法</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-c306c09ce2cefe4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="15、es6-的导入导出【-有两种方法-】">15、ES6 的导入导出【 有两种方法 】</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-509a6564eadac67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="16、actions-在需要用异步操作的时候用得到">16、actions 在需要用异步操作的时候用得到</h5> <h5 id="17、面向对象编程：封装、继承、多态">17、面向对象编程：封装、继承、多态</h5> <h5 id="18、npm-与-nodemon-的区别">18、npm 与 nodemon 的区别</h5> <pre><code>npm 是运行一个命令，如npm run dev\nnodemon 是运行一个 js 文件 ，如 如 nodemon app.js</code></pre><h5 id="19、路由传参的方法">19、路由传参的方法</h5> <pre><code class="language-js">1》、动态路由    // ------》接收 params \n2》、path + query \n3》、naem + params</code></pre> <h5 id="20、组件合并用到的路由监听">20、组件合并用到的路由监听</h5> <p>this.$toute 可以获取到当前跳转到了那个页面【 path 属性中有路由 】</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-6f95fd38646d7c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="21、disabled-属性">21、disabled 属性</h5> <p>​ 饿了么 UI 常用的用于禁用时的属性，值为 boolean 类型，默认为 false</p> <h5 id="22、finally-不管请求成功或失败都会执行回调">22、.finally 不管请求成功或失败都会执行回调</h5> <pre><code class="language-js">cinemaDetail(cinemaId) {\n    let loading = this.$loading({\n        lock: true,\n        text: &quot;努力加载中...&quot;,\n        background: &quot;rgba(0, 0, 0, 0.7)&quot;\n    });\n    let url = &quot;/cinema/getDetail2?cinemaId=&quot;+ cinemaId;\n    this.$axios.get(url).then(res =&gt; {\n        console.log(res);\n    }).catch(err =&gt; {\n        this.$message.error(err);\n    }).finally(()=&gt; {\n        loading.close();\n    })\n}</code></pre> '},"22ce":function(t,e){t.exports=""},2490:function(t,e){t.exports='<h1 id="vue-中的router-和-route的区别">vue 中的$router 和 $route的区别</h1> <p><a href="https://www.cnblogs.com/czy960731/p/9288830.html">vue 中的$router 和 $route的区别</a></p> <p>1.router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。</p> <p>2.route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等</p> <p>这两个不同的结构可以看出两者的区别，他们的一些属性是不同的。</p> <ul> <li><ul> <li><p>$route.path 字符串，等于当前路由对象的路径，会被解析为绝对路径，如 <code>&quot;/home/news&quot;</code> 。</p> </li> <li><p>$route.params 对象，包含路由中的动态片段和全匹配片段的键值对</p> </li> <li><p>$route.query 对象，包含路由中查询参数的键值对。例如，对于 <code>/home/news/detail/01?favorite=yes</code> ，会得到<code>$route.query.favorite == &#39;yes&#39;</code> 。</p> </li> <li><p>$route.router 路由规则所属的路由器（以及其所属的组件）。</p> </li> <li><p>$route.matched 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p> </li> <li><p>$route.name 当前路径的名字，如果没有使用具名路径，则名字为空。</p> </li> <li><p>参数是 this.$route.query或者 this.$route.params 接收router-link传的参数。</p> </li> </ul> </li> </ul> '},"27d1":function(t,e){t.exports='<h1 id="vue中axios的封装和api接口的管理">vue中Axios的封装和API接口的管理</h1> <p>1、axios的封装</p> <ul> <li><p>安装</p> <pre><code class="language-javascript">npm i axios</code></pre> </li> <li><p>引入</p> <pre><code class="language-javascript">// 在http.js中引入axios\nimport axios from &#39;axios&#39;; // 引入axios\nimport QS from &#39;qs&#39;; // 引入qs模块，用来序列化post类型的数据，后面会提到\n// vant的toast提示框组件，大家可根据自己的ui组件更改。\nimport { Toast } from &#39;vant&#39;; </code></pre> </li> <li><p>环境切换</p> <p>​ 我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址。</p> <pre><code class="language-javascript">// 环境的切换\nif (process.env.NODE_ENV == &#39;development&#39;) {    \n    axios.defaults.baseURL = &#39;https://www.baidu.com&#39;;} \nelse if (process.env.NODE_ENV == &#39;debug&#39;) {    \n    axios.defaults.baseURL = &#39;https://www.ceshi.com&#39;;\n} \nelse if (process.env.NODE_ENV == &#39;production&#39;) {    \n    axios.defaults.baseURL = &#39;https://www.production.com&#39;;</code></pre> </li> </ul> '},3745:function(t,e){t.exports='<h3 id="vue中路由跳转后页面不在顶部问题">vue中路由跳转后页面不在顶部问题</h3> <h5 id="1、方法一：">1、方法一：</h5> <p>​ 在 min.js 文件中添加如下代码：</p> <pre><code class="language-javascript">// 让页面回到顶部\nrouter.afterEach((to,from,next) =&gt; {\n    window.scrollTo(0,0);\n})</code></pre> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-366f3ef2fc47611b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="2、方法二：">2、方法二：</h5> <p>​ 在路由配置页面</p> <pre><code class="language-vue">const routes = [...];\nconst router = new Router({\n  scrollBehavior: () =&gt; ({\n    y: 0\n  }),\n  routes\n});</code></pre> '},4160:function(t,e,n){"use strict";var o=n("23e7"),a=n("17c2");o({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},"42bf":function(t,e,n){"use strict";n("74d8")},"42f8":function(t,e,n){"use strict";n("a07c")},"45fc":function(t,e,n){"use strict";var o=n("23e7"),a=n("b727").some,i=n("a640"),r=n("ae40"),s=i("some"),l=r("some");o({target:"Array",proto:!0,forced:!s||!l},{some:function(t){return a(this,t,arguments.length>1?arguments[1]:void 0)}})},"462a":function(t,e){t.exports='<h1 id="vue-中使用二维码">Vue 中使用二维码</h1> <h3 id="一、安装依赖">一、安装依赖</h3> <pre><code class="language-javascript">npm install --save qrcode</code></pre> <h3 id="二、调用-qrcode-包生成二维码">二、调用 qrcode 包生成二维码</h3> <p>直接在需要使用的组件中 improt </p> <h3 id="三、配置-qrcode-并使用">三、配置 qrcode 并使用</h3> <p>完整代码如下</p> <pre><code class="language-vue">&lt;template&gt;\n  &lt;div class=&quot;system-qrcode&quot;&gt;\n    &lt;canvas id=&quot;canvas&quot; class=&quot;canvas-area&quot;&gt;&lt;/canvas&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport QRCode from &quot;qrcode&quot;;\nexport default {\n  name: &quot;&quot;,\n  components: {},\n  data() {\n    return {\n      qrData: &quot;https://xxxxxx.cloud/index_m.html&quot;\n    };\n  },\n  mounted() {\n    this.useqrcode();\n  },\n  methods: {\n    useqrcode() {\n      let canvas = document.getElementById(&quot;canvas&quot;);\n      // 参数说明： canvas ： 获取 dom 元素\n      // 参数说明： this.qrData ： 需要生成二维码的字符串\n      // 参数说明： 参数三 ： 设置二维码样式\n      QRCode.toCanvas(canvas, this.qrData, { width: 200 });\n    }\n  }\n};\n&lt;/script&gt;</code></pre> '},4759:function(t,e){t.exports='<h1 id="vue-兄弟传参">Vue 兄弟传参</h1> <h5 id="方法一：vuex-相信各位小伙伴都已经很熟了，就不在此赘述了。不懂的小伙伴请移步vuex">方法一：Vuex 相信各位小伙伴都已经很熟了，就不在此赘述了。不懂的小伙伴请移步<a href="https://vuex.vuejs.org">Vuex</a></h5> <h5 id="方法二：bus，利用-bus-可以进行父传子、子传父、兄弟传参操作">方法二：bus，利用 bus 可以进行父传子、子传父、兄弟传参操作</h5> <pre><code class="language-javascript">\n//vue原型链挂载总线 【在min.js文件中】\nVue.prototype.bus = new Vue();\n\n//子组件发送数据，一般是通过事件触发\nthis.bus.$emit(&quot;change&quot;,data);\n\n//子组件（注意：这可以是父组件，也可以是兄弟组件）接收数据\nthis.bus.$on(&quot;change&quot;,function(data){\n\n})</code></pre> <h5 id="demo">demo:</h5> <pre><code class="language-javascript">// 组件通过事件发送数据\nmethods: {\n    fn2 () {\n        this.bus.$emit(&quot;date_key&quot;,&quot;哈哈哈~~~&quot;)\n    }\n}</code></pre> <pre><code class="language-javascript">//子组件接收\ndata() {\n        return {\n            msg:&quot;&quot;\n        }\n    },\nmounted() {\n    this.bus.$on(&quot;date_key&quot;,(e) =&gt; {\n        this.msg = e\n    })\n}</code></pre> '},"52ab":function(t,e){t.exports='<h3 id="vue-进阶--10-18">vue 进阶 10-18</h3> <h3 id="1、vue---cli3-配置环境变量">1、vue - cli3 配置环境变量</h3> <p>​ 我们在做项目的时候,一般需要根据不同的环境使用不同的 ip(或者域名)地址,开发环境使用开发环境的 ip 地址,发布上线之后用的 ip 地址又是另外一个,我常用的两种方案如下：</p> <p>方案一：</p> <ol> <li><p>获取环境变量, 通过 process.env.NODE_ENV,当在开发环境的时候,其值为 development,打包发布的值为 production</p> </li> <li><p>根据不同的环境,赋不同的 IP 地址</p> <pre><code class="language-js">import axios from &quot;axios&quot;;\nimport router from &quot;../router&quot;;\nlet env = process.env.NODE_ENV;\nlet baseURL;\nif (env === &quot;development&quot;) {\n  baseURL = &quot;http://localhost:3006&quot;;\n} else {\n  baseURL = &quot;http://huruqing.cn:3006&quot;;\n}\n\n// 创建axios实例\nconst service = axios.create({\n  baseURL,\n  timeout: 5000\n});</code></pre> <p>相对于方案二的好处是,我去修改 ip 地址不需要重启服务</p> </li> </ol> <p> 方案二：</p> <ol> <li><p>在项目根目录新建两个文件 <strong>.env.development</strong> <strong>.env.production</strong></p> <pre><code class="language-javascript">// .env.development\nVUE_APP_URL = &quot;http://localhost:3006&quot;;</code></pre> <pre><code class="language-javascript">// .env.production\nVUE_APP_URL = &quot;http://test.huruqing.com&quot;;</code></pre> <p>配置好之后,在项目的其他的地方可以使用 process.env.VUE_APP_URL</p> </li> <li><p>若是我们使用的是 axios 请求数据,则可以配置 axios 的 baseURL</p> <pre><code class="language-javascript">const service = axios.create({\n  // 配置基本的路径\n  baseURL: process.env.VUE_APP_URL,\n  timeout: 5000\n});</code></pre> </li> </ol> <h3 id="2、mixin-（-混入-）">2、mixin （ 混入 ）</h3> <h5 id="前言">前言</h5> <p>​ minxin 其实是一个对象，里面的结构大致跟普通组件的 script 里面的一样，有 data 属性，钩子函数和方法等 混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。【 如果原对象与混入对象的属性相同，则取原对象 】</p> <h5 id="在实际项目中，可以新建一个-js-文件，导出一个-minxin-对象-在引用的组件中引入使用即可">在实际项目中，可以新建一个 js 文件，导出一个 minxin 对象 在引用的组件中引入使用即可</h5> <h5 id="一个简单的例子"><a href="http://huruqing.cn/docs/Vue/advance/11.minxin.html#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">#</a>一个简单的例子</h5> <pre><code class="language-vue">// demo.vue\n&lt;template&gt;\n  &lt;div&gt;{{ $data }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport mixin from &quot;./mixin&quot;;\nexport default {\n  mixins: [mixin],\n  data: function() {\n    return {\n      message: &quot;老胡&quot;,\n      sex: &quot;男&quot;\n    };\n  },\n  created: function() {\n    console.log(this.$data);\n    // =&gt; { username: &quot;老胡&quot;, sex: &quot;男&quot;, age: 100 }\n  }\n};\n&lt;/script&gt;\n// minxin.js\nexport default {\n  data: function() {\n    return {\n      username: &quot;huruqing&quot;,\n      age: 100\n    };\n  }\n};</code></pre> <h5 id="全局导入-mixin"><a href="http://huruqing.cn/docs/Vue/advance/11.minxin.html#%E5%85%A8%E5%B1%80%E5%AF%BC%E5%85%A5-mixin">#</a>全局导入 mixin</h5> <ol> <li>在根目录下新建/src/mixin/index.js,可以 js 里面定义 data,filters,methods 等,全局混入,然后整个项目都可以使用了</li> </ol> <pre><code class="language-javascript">// mixin.js\nimport axios from &quot;axios&quot;;\nexport default {\n  data() {\n    return {\n      loading: false,\n      loadingObj: {}\n    };\n  },\n  filters: {\n    formatDate(time) {\n      let date = new Date(time);\n      let Y = date.getFullYear();\n      let M = date.getMonth() + 1;\n      let D = date.getDate();\n\n      Y = Y &lt; 10 ? &quot;0&quot; + Y : Y;\n      D = D &lt; 10 ? &quot;0&quot; + D : D;\n      return `${Y}-${M}-${D}`;\n    }\n  },\n  methods: {\n    // 封装请求\n    $get(url, data) {\n      return axios.get(url, { params: data });\n    },\n    $post(url, data) {\n      return axios.post(url, data);\n    }, // 饿了么的loading用起来不痛快,封装一下\n    startLoading() {\n      this.loadingObj = this.$loading({\n        lock: true,\n        text: &quot;Loading...&quot;,\n        spinner: &quot;el-icon-loading&quot;,\n        background: &quot;rgba(0, 0, 0, 0.7)&quot;\n      });\n    }, // 关闭loading\n    closeLoading() {\n      this.loadingObj.close();\n    }\n  }\n};</code></pre> <p>2.在 main.js 全局混入</p> <pre><code class="language-javascript">import Vue from &quot;vue&quot;;\n\nimport mixinObj from &quot;@/mixin/index&quot;;\nVue.mixin(mixinObj);\n\nnew Vue({\n  // todo\n});</code></pre> <p>3.在组件中使用</p> <pre><code class="language-vue">// demo.vue\n&lt;template&gt;\n    // 利用 filters 格式化时间\n    &lt;div&gt;{{ time | formatDate }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      time: Date.now()\n    };\n  },\n  created() {\n    // 调用loading\n    this.startLoading();\n    setTimeout(() =&gt; {\n      // 关闭loading\n      this.closeLoading();\n    }, 2000);\n  }\n};\n&lt;/script&gt;</code></pre> <h5 id="局部混入-mixin-步骤">局部混入 mixin 步骤</h5> <p>1、创建 mixin 文件</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-adcfaa02c7361bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>2、局部文件导入 mixin </p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-9c79b1e9a3a25369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h3 id="3、filter">3、filter</h3> <h5 id="vue-实例之前全局定义过滤器：">Vue 实例之前全局定义过滤器：</h5> <pre><code class="language-javascript">Vue.filter(&#39;capitalize&#39;, function (value) {\n  if (!value) return &#39;&#39;\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n\nnew Vue({\n  // ...\n})</code></pre> <h5 id="在组件内使用"><a href="http://huruqing.cn/docs/Vue/advance/09.filter.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E4%BD%BF%E7%94%A8">#</a>在组件内使用</h5> <ul> <li>在组件内定义 filter formatDate</li> <li>在 template 中使用,有两种使用方式{{}}和属性绑定</li> </ul> <pre><code class="language-vue">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;时间: {{time | formatDate}}&lt;/p&gt;\n\n    &lt;input :value=&quot;time | formatDate&quot; /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      time: 1571209089334\n    };\n  },\n\n  filters: {\n    formatDate(time) {\n      let date = new Date(time);\n      let Y = date.getFullYear();\n      let M = date.getMonth() + 1;\n      let D = date.getDate();\n\n      Y = Y &lt; 10 ? &quot;0&quot; + Y : Y;\n      D = D &lt; 10 ? &quot;0&quot; + D : D;\n      return `${Y}-${M}-${D}`;\n    }\n  }\n};\n&lt;/script&gt;</code></pre> <p>ps: 也可以使用 minxin,定义 filter</p> <pre><code class="language-javascript">let minxin = {\n  filters: {\n    formatDate() {\n      // todo\n    }\n  }\n}\n\nnew Vue({\n  minxin ,\n\n})</code></pre> <h3 id="4、keep-alive">4、keep-alive</h3> <p>缓存组件（ 让组件不销毁 ）</p> <h3 id="5、token">5、token</h3> <p>识别用户</p> <h3 id="6、自定义指令">6、自定义指令</h3> <h3 id="7、权限控制">7、权限控制</h3> <p>不同的用户，展示不同的页面。</p> <p>不同的用户，有不同的功能</p> <h3 id="8、父组件把方法传递给子组件">8、父组件把方法传递给子组件</h3> <p>​ <a href="https://www.cnblogs.com/wzfwaf/p/11280153.html">https://www.cnblogs.com/wzfwaf/p/11280153.html</a></p> <h3 id="9、post请求中的序列化">9、post请求中的序列化</h3> <p>1、序列化：encode</p> <p>2、GET方式，会将表单中的数据（键值对）经过urlencode编码后追加到url中。</p> <p>3、POST方式，会将表单中的数据经过urlencode编码后放在request body 中。</p> <h3 id="10、拦截器：">10、拦截器：</h3> <p>​ 请求拦截器：在求情之前带上 token</p> <p>​ 响应拦截器：在请求之后对响应回来的数据进行一个处理</p> '},5319:function(t,e,n){"use strict";var o=n("d784"),a=n("825a"),i=n("7b0b"),r=n("50c4"),s=n("a691"),l=n("1d80"),p=n("8aa5"),u=n("14c3"),c=Math.max,d=Math.min,g=Math.floor,m=/\$([$&'`]|\d\d?|<[^>]*>)/g,h=/\$([$&'`]|\d\d?)/g;o("replace",2,(function(t,e,n,o){var f=o.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,v=o.REPLACE_KEEPS_$0,q=f?"$":"$0";return[function(n,o){var a=l(this),i=null==n?void 0:n[t];return void 0!==i?i.call(n,a,o):e.call(String(a),n,o)},function(t,o){if(!f&&v||"string"==typeof o&&-1===o.indexOf(q)){var i=n(e,t,this,o);if(i.done)return i.value}var l=a(t),g=String(this),m="function"==typeof o;m||(o=String(o));var h=l.global;if(h){var w=l.unicode;l.lastIndex=0}for(var x=[];;){var y=u(l,g);if(null===y)break;if(x.push(y),!h)break;""===String(y[0])&&(l.lastIndex=p(g,r(l.lastIndex),w))}for(var j,E="",k=0,V=0;V<x.length;V++){y=x[V];for(var _=String(y[0]),C=c(d(s(y.index),g.length),0),U=[],A=1;A<y.length;A++)U.push(void 0===(j=y[A])?j:String(j));var $=y.groups;if(m){var M=[_].concat(U,C,g);void 0!==$&&M.push($);var S=String(o.apply(void 0,M))}else S=b(_,g,C,U,$,o);C>=k&&(E+=g.slice(k,C)+S,k=C+_.length)}return E+g.slice(k)}];function b(t,n,o,a,r,s){var l=o+t.length,p=a.length,u=h;return void 0!==r&&(r=i(r),u=m),e.call(s,u,(function(e,i){var s;switch(i.charAt(0)){case"$":return"$";case"&":return t;case"`":return n.slice(0,o);case"'":return n.slice(l);case"<":s=r[i.slice(1,-1)];break;default:var u=+i;if(0===u)return e;if(u>p){var c=g(u/10);return 0===c?e:c<=p?void 0===a[c-1]?i.charAt(1):a[c-1]+i.charAt(1):e}s=a[u-1]}return void 0===s?"":s}))}}))},5434:function(t,e){t.exports='<h2 id="v-model-与-sync-的异同点">v-model 与 .sync 的异同点</h2> <h3 id="使用sync更优雅的实现数据双向绑定">使用<code>.sync</code>,更优雅的实现数据双向绑定</h3> <p>在<code>Vue</code>中，<code>props</code>属性是单向数据传输的,父级的prop的更新会向下流动到子组件中，但是反过来不行。可是有些情况，我们需要对prop进行“双向绑定”。上文中，我们提到了使用<code>v-model</code>实现双向绑定。但有时候我们希望一个组件可以实现多个数据的“双向绑定”，而<code>v-model</code>一个组件只能有一个(Vue3.0可以有多个)，这时候就需要使用到<code>.sync</code>。</p> <h4 id="sync与v-model的异同"><code>.sync</code>与<code>v-model</code>的异同</h4> <blockquote> <p>相同点：</p> <ul> <li>两者的本质都是语法糖，目的都是实现组件与外部数据的双向绑定</li> <li>两个都是通过属性+事件来实现的</li> </ul> <p>不同点(个人观点，如有不对，麻烦下方评论指出，谢谢)：</p> <ul> <li>一个组件只能定义一个<code>v-model</code>,但可以定义多个<code>.sync</code></li> <li><code>v-model</code>与<code>.sync</code>对于的事件名称不同，<code>v-model</code>默认事件为<code>input</code>,可以通过配置<code>model</code>来修改，<code>.sync</code>事件名称固定为<code>update:属性名</code></li> </ul> </blockquote> <h4 id="自定义sync">自定义<code>.sync</code></h4> <p>应用场景：在开发业务时，有时候需要使用一个遮罩层例如 <a href="https://element.eleme.cn/#/zh-CN/component/dialog">element UI Dialog 对话框</a> 的弹框。在父组件点击按钮弹框，在子组件点击按钮关闭弹框。子组件不能直接修改 props 的值，那么就可以利用 .sync 来优雅的实现数据双向绑定：</p> <h5 id="子组件：">子组件：</h5> <pre><code class="language-javascript">&lt;template&gt;\n  &lt;div class=&quot;modal&quot; v-show=&quot;visible&quot;&gt;\n    &lt;div class=&quot;dc-modal&quot;&gt;\n      &lt;div class=&quot;handle-area&quot;&gt;\n        &lt;button @click=&quot;handClose&quot;&gt;点我关闭&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#39;modal&#39;,\n  components: {},\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data () {\n    return {}\n  },\n  methods: {\n    handClose () {\n      this.$emit(&#39;update:visible&#39;, false)    // 注意这里的 &#39;update:【这里不能有空格】visible&#39;\n    }\n  }\n}\n&lt;/script&gt;\n\n&lt;style lang=&#39;less&#39; scoped&gt;\n.modal {\n  // height: 100vh;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background: rgba(0, 0, 0, 0.4);\n  .dc-modal {\n    width: 100vw;\n    height: 100vh;\n    position: relative;\n  }\n  .handle-area {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -100px;\n    margin-left: -100px;\n    width: 200px;\n    height: 200px;\n    background: #fff;\n  }\n}\n&lt;/style&gt;</code></pre> <h5 id="父组件：">父组件：</h5> <pre><code class="language-javascript">&lt;template&gt;\n  &lt;div class=&quot;sync-test-page&quot;&gt;\n    &lt;button @click=&quot;clickMe&quot;&gt;点我弹框&lt;/button&gt;\n    &lt;Modal :visible.sync=&quot;visible&quot;&gt;&lt;/Modal&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Modal from &#39;@/components/modal/index&#39;\nexport default {\n  name: &#39;&#39;,\n  components: { Modal },\n  data () {\n    return {\n      visible: false\n    }\n  },\n  methods: {\n    clickMe () {\n      this.visible = true\n    }\n  }\n}\n&lt;/script&gt;\n\n&lt;style lang=&#39;less&#39; scoped&gt;\n&lt;/style&gt;</code></pre> '},6289:function(t,e){t.exports='<h1 id="github-操作说明">github 操作说明</h1> <h5 id="1、注册-github-账号：httpsgithubcom">1、注册 github 账号：<a href="https://github.com/">https://github.com/</a></h5> <h5 id="2、创建仓库：-new-repository">2、创建仓库： New repository</h5> <h5 id="3、配置ssh秘钥（非必须：如果提交代码的过程中提示无权限则需要进行配置）">3、配置ssh秘钥（非必须：如果提交代码的过程中提示无权限则需要进行配置）</h5> <h5 id="4、按照如下步骤进行代码提交：">4、按照如下步骤进行代码提交：</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-9147173d0a8bbf9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id=""></h5> <h3 id="常见问题：">常见问题：</h3> <h5 id="1、【github】git-push错误failed-to-push-some-refs-to的解决">1、<a href="https://blog.csdn.net/rocling/article/details/82956402">【github】git push错误failed to push some refs to的解决</a></h5> <p>解决方案：</p> <p>​ 这个问题是因为远程库与本地库不一致造成的，那么我们把远程库同步到本地库就可以了。 使用指令。</p> <pre><code>git pull --rebase origin master</code></pre><h5 id="2、通过强推的方法，把之前的代码覆盖掉">2、通过强推的方法，把之前的代码覆盖掉</h5> <pre><code>git push origin master -u -f</code></pre>'},6547:function(t,e,n){var o=n("a691"),a=n("1d80"),i=function(t){return function(e,n){var i,r,s=String(a(e)),l=o(n),p=s.length;return l<0||l>=p?t?"":void 0:(i=s.charCodeAt(l))<55296||i>56319||l+1===p||(r=s.charCodeAt(l+1))<56320||r>57343?t?s.charAt(l):i:t?s.slice(l,l+2):r-56320+(i-55296<<10)+65536}};t.exports={codeAt:i(!1),charAt:i(!0)}},"67b5":function(t,e){t.exports='<h1 id="consoledir和consolelog的区别">console.dir()和console.log()的区别</h1> <p>​ console.log()可以取代alert()或document.write()，在网页脚本中使用console.log()时，会在浏览器控制台打印出信息。</p> <p>​ console.dir()可以显示一个对象所有的属性和方法。</p> '},"72e0":function(t,e){t.exports='<h3 id="关于vue的冷知识">关于vue的冷知识</h3> <h5 id="一、如何查看vue-的版本号">一、如何查看vue 的版本号</h5> <pre><code>vue -V 可看到vue的版本号。</code></pre><h5 id="二、开发-vue-项目-npm-run-servedev-时没有自动打开浏览器，还得自己输入-ip-或-localhost，想让浏览器自动打开，需要做以下配置">二、开发 vue 项目 npm run serve/dev 时没有自动打开浏览器，还得自己输入 ip 或 localhost，想让浏览器自动打开，需要做以下配置:</h5> <p>​ 1、使用 vue-cli <strong>老版本</strong> 构建项目时， 可修改config文件夹下index.js文件 autoOpenBrowser 属性给为 true 即可</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-8e18c95a821035ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>​ 2、使用<strong>vue-cli 3.x</strong> 版本后，所有的配置项均在vue.config.js中，修改 devServer 增加 open 属性为 true 即可</p> <pre><code class="language-javascript">module.exports = {\n    //   设置自动打开页面\n    devServer:{\n        //   设置主机地址\n        // host:&quot;loaclhost&quot;\n        host:&quot;192.168.1.5&quot;,\n        // 设置默认端口\n        port:&quot;8888&quot;,\n        // 自动打开浏览器\n        open:true\n    }\n}</code></pre> <h5 id="三、babelrc-----》转码器">三、.babelrc ----》转码器</h5> <p>​ Babel 转码器 § es6转换es5 实时转码 / Repl -babel-node / babel-register(自动转码引入babel-register模块)</p> <p>配置文件.babelrc</p> <p><a href="https://www.cnblogs.com/wangweizhang/p/7259338.html">https://www.cnblogs.com/wangweizhang/p/7259338.html</a></p> <h5 id="四、合理的使用小知识">四、合理的使用小知识</h5> <p>​ 1、短路运算</p> <pre><code class="language-json">&amp;&amp; 短路： 当&amp;&amp;左边为true的时候，结果就跟左边没有关系了，直接得到&amp;&amp;的右边（执行结果）\n\n|| 短路： 当||的左边为false，结果就跟左边没关系，直接得到||右边的执行结果 （函数传参取默认值常用）</code></pre> <pre><code class="language-javascript">function test(data) {\n    data = data || {};\n    console.log(data.aa);\n}</code></pre> <p>​ 不仅可以用于设置默认值，也可用于避免无意义的报错。</p> <h5 id="五、关于-vue-中的父子通信">五、关于 vue 中的父子通信</h5> <p>​ 父传子，自定义属性<strong>不一定需要用(冒号) ：</strong> ，如果是<strong>变量</strong>就需要用 ： ，如果是<strong>字符串</strong>就不需要用：</p> <p>​ <strong>react</strong> 同理..................................................{} ,................变量................{} ，.............字符串.................{}</p> <h5 id="六、获取-vuex-中的值得方法：">六、获取 vuex 中的值得方法：</h5> <p>​ mapState、mapGetters、mapActions</p> '},"74d8":function(t,e,n){},7636:function(t,e){t.exports='<h1 id="es6-中-class-的使用">ES6 中 class 的使用</h1> <pre><code>// 父类 \nclass Person {\n    constructor(name,age) {\n        this.name = name\n        this.age = age\n    }\n\n    sayName() {\n        console.log( &quot;My name is &quot; + this.name )\n    }\n}\n\n// 子类通过extends继承父类属性和方法,同时必须调用 super()【super()内部的this指向的是worker非Person】\nclass worker extends Person {\n    constructor(name,age,job) {\n        super(name,age)\n        this.job = job\n    }\n\n    sayMyInfo() {\n        console.log( &quot;姓名：&quot; + this.name + &quot; ；年龄：&quot; + this.age + &quot;;工作：&quot; + this.job )\n    }\n}\n\nlet workers = new worker(&quot;张三&quot;,18,&quot;teacher&quot;)\nconsole.log(workers)\nworkers.sayName()       // 调用父类的方法\nworkers.sayMyInfo()     // 调用子类的方法</code></pre><p>参考文档：<a href="https://www.php.cn/js-tutorial-384115.html">https://www.php.cn/js-tutorial-384115.html</a></p> '},"85c5":function(t,e){t.exports='<h3 id="更改this指向的三个方法">更改this指向的三个方法</h3> <h5 id="1call-方法">1.call() 方法</h5> <pre><code>var Person = {\n        name:&quot;lixue&quot;,\n        age:21\n    }\n    function fn(x,y){\n        console.log(x+&quot;,&quot;+y);\n        console.log(this);\n    }\n    fn(&quot;hh&quot;,20);</code></pre><h5 id="2apply-方法">2.apply() 方法</h5> <p>​ apply() 与call（）非常相似，不同之处在于提供参数的方式，apply（）使用参数数组，而不是参数列表。</p> <h5 id="3bind方法">3.bind()方法</h5> <p>​ bind()创建的是一个新的函数（称为绑定函数），与被调用函数有相同的函数体，当目标函数被调用时this的值绑定到 bind()的第一个参数上。</p> '},"8aa5":function(t,e,n){"use strict";var o=n("6547").charAt;t.exports=function(t,e,n){return e+(n?o(t,e).length:1)}},9263:function(t,e,n){"use strict";var o,a,i=n("ad6d"),r=n("9f7fd"),s=RegExp.prototype.exec,l=String.prototype.replace,p=s,u=(o=/a/,a=/b*/g,s.call(o,"a"),s.call(a,"a"),0!==o.lastIndex||0!==a.lastIndex),c=r.UNSUPPORTED_Y||r.BROKEN_CARET,d=void 0!==/()??/.exec("")[1];(u||d||c)&&(p=function(t){var e,n,o,a,r=this,p=c&&r.sticky,g=i.call(r),m=r.source,h=0,f=t;return p&&(-1===(g=g.replace("y","")).indexOf("g")&&(g+="g"),f=String(t).slice(r.lastIndex),r.lastIndex>0&&(!r.multiline||r.multiline&&"\n"!==t[r.lastIndex-1])&&(m="(?: "+m+")",f=" "+f,h++),n=new RegExp("^(?:"+m+")",g)),d&&(n=new RegExp("^"+m+"$(?!\\s)",g)),u&&(e=r.lastIndex),o=s.call(p?n:r,f),p?o?(o.input=o.input.slice(h),o[0]=o[0].slice(h),o.index=r.lastIndex,r.lastIndex+=o[0].length):r.lastIndex=0:u&&o&&(r.lastIndex=r.global?o.index+o[0].length:e),d&&o&&o.length>1&&l.call(o[0],n,(function(){for(a=1;a<arguments.length-2;a++)void 0===arguments[a]&&(o[a]=void 0)})),o}),t.exports=p},"961c":function(t,e){t.exports=""},"9a51":function(t,e,n){var o={"./CSS/CSS文件1.md":"22ce","./ES6+/ES6 中 class 的使用.md":"7636","./ES6+/ES6.md":"961c","./ES6+/JSONP 跨域.md":"1bf9","./ES6+/Promise.all.md":"20e4","./ES6+/asyncawait 优雅的错误处理方法.md":"cabe","./ES6+/asyncawait 的理解.md":"f58e","./ES6+/console.dir()和console.log()的区别.md":"67b5","./ES6+/更改this指向的三个方法.md":"85c5","./HTML/HTML文件1.md":"d995","./JS/JS文件1.md":"0229","./VUE/Qrcode使用.md":"462a","./VUE/Vue Router 之导航守卫.md":"ab3f","./VUE/Vue 兄弟传参--bus.md":"4759","./VUE/v-model与sync.md":"5434","./VUE/vue filter 常用功能.md":"d9a8","./VUE/vue 中子（父）组件触发父（子）组件中的方法.md":"1b04","./VUE/vue 中的$router 和 $route的区别.md":"2490","./VUE/vue 自定义组件 v-model双向绑定、 父子组件同步通信.md":"0a9a","./VUE/vue 进阶  10-18.md":"52ab","./VUE/vue-router 路由传参.md":"be43","./VUE/vue中Axios的封装和API接口的管理.md":"27d1","./VUE/vue中iconfont 字体图标使用的两种方法.md":"ea8f","./VUE/vue中关于插槽的理解.md":"ef95","./VUE/vue中常用的事件修饰符.md":"cf01","./VUE/vue中的路由监听与vuex state中数据监听及其组合使用.md":"c5f2","./VUE/vue全局变量和Vue.prototype.md":"d3ea","./VUE/webpack 的使用.md":"ea63","./VUE/五种循环遍历的方法.md":"d0e2","./VUE/使用rem编写自适应屏幕网页造成div被span撑高的解决办法（网络方法）.md":"b35e","./VUE/关于 VUE 中的父子传值.md":"1017","./VUE/关于 vant 组件按需引入问题.md":"1abb","./VUE/关于input中的checked属性.md":"0cf0","./VUE/关于vue的冷知识.md":"72e0","./VUE/动态路由.md":"fdc8","./VUE/卖座后管小知识点.md":"21ff","./VUE/卖座城市列表渲染.md":"f8e3","./VUE/如何创建一个新项目.md":"19b4","./VUE/小程序项目分享.md":"c5e9","./VUE/扩展运算符.md":"04aa","./VUE/数组常用的方法.md":"f3e6","./VUE/路由跳转后页面不在顶部问题.md":"3745","./正则表达式/github操作说明.md":"6289"};function a(t){var e=i(t);return n(e)}function i(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}a.keys=function(){return Object.keys(o)},a.resolve=i,t.exports=a,a.id="9a51"},"9f7fd":function(t,e,n){"use strict";var o=n("d039");function a(t,e){return RegExp(t,e)}e.UNSUPPORTED_Y=o((function(){var t=a("a","y");return t.lastIndex=2,null!=t.exec("abcd")})),e.BROKEN_CARET=o((function(){var t=a("^r","gy");return t.lastIndex=2,null!=t.exec("str")}))},a07c:function(t,e,n){},a640:function(t,e,n){"use strict";var o=n("d039");t.exports=function(t,e){var n=[][t];return!!n&&o((function(){n.call(null,e||function(){throw 1},1)}))}},a7ae:function(t,e,n){},ab3f:function(t,e){t.exports='<h3 id="vue-router-之导航守卫">Vue Router 之导航守卫</h3> <h5 id="1、全局前置守卫-----》在路由守卫处常用">1、全局前置守卫-----》在路由守卫处常用</h5> <pre><code class="language-js">const router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) =&gt; {\n  // ...\n})</code></pre> <p>每个守卫方法接收三个参数：</p> <ul> <li><strong>to: Route</strong>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></li> <li><strong>from: Route</strong>: 当前导航正要离开的路由</li> <li><strong>next: Function</strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</li> </ul> <h5 id="2、全局后置钩子">2、全局后置钩子</h5> <p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p> <pre><code>router.afterEach((to, from) =&gt; {\n  // ...\n})</code></pre><h5 id="3、路由独享守卫">3、路由独享守卫</h5> <p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p> <pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/foo&#39;,\n      component: Foo,\n      beforeEnter: (to, from, next) =&gt; {\n        // ...\n      }\n    }\n  ]\n})</code></pre><p>这些守卫与全局前置守卫的方法参数是一样的。</p> <h5 id="4、组件内的守卫">4、组件内的守卫</h5> <p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p> <ul> <li><code>beforeRouteEnter</code></li> <li><code>beforeRouteUpdate</code> (2.2 新增)</li> <li><code>beforeRouteLeave</code></li> </ul> <pre><code class="language-js">const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}</code></pre> <p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p> <p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p> <pre><code class="language-js">export default {\n    data() {\n        return {\n            fromRouter:&quot;&quot;\n        };\n    },\n\n    beforeRouteEnter (to, from, next) {\n        next(vm =&gt; {\n            vm.fromRouter = from.path \n            // 通过 `vm` 访问组件实例，注意【是 vm.fromRouter】 【而不是 vm.data.fromRouter】\n        })\n    }\n}</code></pre> <p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p> <pre><code class="language-js">beforeRouteUpdate (to, from, next) {\n  // just use `this`\n  this.name = to.params.name\n  next()\n}</code></pre> <p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p> <pre><code class="language-js">beforeRouteLeave (to, from , next) {\n  const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)\n  if (answer) {\n    next()\n  } else {\n    next(false)\n  }\n}</code></pre> <h2 id="完整的导航解析流程"><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">#</a>完整的导航解析流程</h2> <ol> <li>导航被触发。</li> <li>在失活的组件里调用离开守卫。</li> <li>调用全局的 <code>beforeEach</code> 守卫。</li> <li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li> <li>在路由配置里调用 <code>beforeEnter</code>。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li> <li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 <code>afterEach</code> 钩子。</li> <li>触发 DOM 更新。</li> <li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li> </ol> '},ac1f:function(t,e,n){"use strict";var o=n("23e7"),a=n("9263");o({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},ad6d:function(t,e,n){"use strict";var o=n("825a");t.exports=function(){var t=o(this),e="";return t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.sticky&&(e+="y"),e}},b35e:function(t,e){t.exports='<h3 id="使用rem编写自适应屏幕网页造成div被span撑高的解决办法（网络方法）">使用rem编写自适应屏幕网页造成div被span撑高的解决办法（网络方法）</h3> <p><img src="C:%5CUsers%5CTHINK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567600282363.png" alt="1567600282363"> <img src="C:%5CUsers%5CTHINK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567600308466.png" alt="1567600308466"></p> '},b670:function(t,e,n){"use strict";n("a7ae")},bce9:function(t,e,n){var o={"./CSS/CSS文件1.md":"22ce","./ES6+/ES6 中 class 的使用.md":"7636","./ES6+/ES6.md":"961c","./ES6+/JSONP 跨域.md":"1bf9","./ES6+/Promise.all.md":"20e4","./ES6+/asyncawait 优雅的错误处理方法.md":"cabe","./ES6+/asyncawait 的理解.md":"f58e","./ES6+/console.dir()和console.log()的区别.md":"67b5","./ES6+/更改this指向的三个方法.md":"85c5","./HTML/HTML文件1.md":"d995","./JS/JS文件1.md":"0229","./VUE/Qrcode使用.md":"462a","./VUE/Vue Router 之导航守卫.md":"ab3f","./VUE/Vue 兄弟传参--bus.md":"4759","./VUE/v-model与sync.md":"5434","./VUE/vue filter 常用功能.md":"d9a8","./VUE/vue 中子（父）组件触发父（子）组件中的方法.md":"1b04","./VUE/vue 中的$router 和 $route的区别.md":"2490","./VUE/vue 自定义组件 v-model双向绑定、 父子组件同步通信.md":"0a9a","./VUE/vue 进阶  10-18.md":"52ab","./VUE/vue-router 路由传参.md":"be43","./VUE/vue中Axios的封装和API接口的管理.md":"27d1","./VUE/vue中iconfont 字体图标使用的两种方法.md":"ea8f","./VUE/vue中关于插槽的理解.md":"ef95","./VUE/vue中常用的事件修饰符.md":"cf01","./VUE/vue中的路由监听与vuex state中数据监听及其组合使用.md":"c5f2","./VUE/vue全局变量和Vue.prototype.md":"d3ea","./VUE/webpack 的使用.md":"ea63","./VUE/五种循环遍历的方法.md":"d0e2","./VUE/使用rem编写自适应屏幕网页造成div被span撑高的解决办法（网络方法）.md":"b35e","./VUE/关于 VUE 中的父子传值.md":"1017","./VUE/关于 vant 组件按需引入问题.md":"1abb","./VUE/关于input中的checked属性.md":"0cf0","./VUE/关于vue的冷知识.md":"72e0","./VUE/动态路由.md":"fdc8","./VUE/卖座后管小知识点.md":"21ff","./VUE/卖座城市列表渲染.md":"f8e3","./VUE/如何创建一个新项目.md":"19b4","./VUE/小程序项目分享.md":"c5e9","./VUE/扩展运算符.md":"04aa","./VUE/数组常用的方法.md":"f3e6","./VUE/路由跳转后页面不在顶部问题.md":"3745","./正则表达式/github操作说明.md":"6289"};function a(t){var e=i(t);return n(e)}function i(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}a.keys=function(){return Object.keys(o)},a.resolve=i,t.exports=a,a.id="bce9"},be43:function(t,e){t.exports='<h3 id="vue-router----路由传参">vue-router 路由传参</h3> <h5 id="注意：">注意：</h5> <p>​ 不管是 get 还是 post 传参，数据是个对象（除非拼接一个 url）</p> <pre><code class="language-js">// 获取商品详情\ngetDetail( productId ){\n    let url = &quot;/product/detail?productId=&quot; + productId\n    this.$axios.post( url ).then(res =&gt; {\n        console.log(res)\n    }).catch(err =&gt; {\n        console.log(err)\n    })\n}\n\n// 获取商品详情\ngetDetail( data ){                   -------》 data 是个对象\n    let url = &quot;/product/detail&quot;\n    this.$axios.post( url,data ).then(res =&gt; {\n        console.log(res)\n    }).catch(err =&gt; {\n        console.log(err)\n    })\n}</code></pre> <h4 id="一、用-name-来识别路由跳转">一、用 name 来识别路由跳转</h4> <p>1、params:参数不会显示到路径上（网址处）</p> <p>​ params 传参在页面 f5 刷新时会被清除</p> <pre><code class="language-js">// 用路由名称 name 来识别路由进行跳转，用 params 来进行传参\nthis.$router.push({\n    name:&quot;Me&quot;,\n    params:this.data        ----------》只能是个对象\n})\n\n// 接收参数\nthis.$route.params    // --------&gt; 注意 toute 不是 router</code></pre> <p>2、query:传参会显示在路径上（网址处）</p> <p>​ query 传参在页面 f5 刷新时不会被清除</p> <pre><code class="language-js">// 用路由名称 name 来识别路由，用 query 来进行传参\nthis.$router.push({\n    name:&quot;Me&quot;,\n    query:this.data            ----------》只能是个对象\n})\n\n// 接收参数\nthis.$route.query    // -----------&gt; 注意 route 不是 router</code></pre> <h4 id="二、用-path-来识别路由跳转">二、用 path 来识别路由跳转</h4> <p>1、query:传参会显示在路径上（网址处） 【成功】</p> <p>​ query 传参在页面 f5 刷新时不会被清除</p> <pre><code class="language-js">this.$router.push({\n    path:&quot;/me&quot;,\n    query:this.data            ----------》只能是个对象\n})\n\n// 接收参数\nthis.$route.query     // -----------&gt; 注意 route 不是 router</code></pre> <p>1、params:参数不会显示到路径上（网址处）</p> <p>​ 传递失败，能跳转无法传递数据 【接收数据结果为 undefind 】</p> <pre><code class="language-js">this.$router.push({\n    path:&quot;/me&quot;,\n    params:this.data        ----------》只能是个对象\n})\n\n// 接收参数\nthis.$route.params    // --------&gt; 注意 toute 不是 router</code></pre> '},c259:function(t,e,n){"use strict";n.r(e);n("4160"),n("d81d"),n("45fc"),n("d3b7"),n("ac1f"),n("5319"),n("159b"),n("ddb0");var o=n("3cad"),a=n("f4e6"),i=n("e708"),r={name:"ZP-dialog",components:{},props:{title:{type:String,default:"提示"},width:{type:String,default:"50%"},top:{type:String,default:"15vh"},visible:{type:Boolean,default:!1}},data:function(){return{}},methods:{handClose:function(){console.log("哈哈"),this.$emit("update:visible",!1)}}},s=(n("42f8"),n("2877")),l={name:"BlogFileDetail",components:{Dialog:Object(s.a)(r,(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("transition",{attrs:{name:"dialog-fade"}},[n("div",{directives:[{name:"show",rawName:"v-show",value:t.visible,expression:"visible"}],staticClass:"zp-dialog__wrapper",on:{click:function(e){return e.target!==e.currentTarget?null:t.handClose(e)}}},[n("div",{staticClass:"zp-dialog",style:{width:t.width,top:t.top}},[n("div",{staticClass:"zp-dialog__header"},[t._t("title",[n("span",{staticClass:"zp-dialog__title"},[t._v(t._s(t.title))])]),n("button",{staticClass:"zp-dialog__headerbtn",on:{click:t.handClose}},[n("i",{staticClass:"iconfont"},[t._v("")])])],2),n("div",{staticClass:"zp-dialog__body"},[t._t("default")],2),t.$slots.footer?n("div",{staticClass:"zp-dialog__footer"},[t._t("footer")],2):t._e()])])])}),[],!1,null,"4104cf2e",null).exports},props:{filePath:{type:String,default:""}},data:function(){return{handbook:"",currentUrl:"",visible:!1}},watch:{filePath:{handler:function(t,e){t&&t!==e&&(this.handbook=n("bce9")("./".concat(t,".md")))},immediate:!0}},mounted:function(){var t=this;setTimeout((function(){t.globalLoading(!1)}),a.a)},methods:{showImage:function(t){t&&"IMG"===t.target.tagName&&(this.visible=!0,this.currentUrl=t.target.currentSrc)}}};n("b670");var p={name:"BlogTechnology",components:{fileDetail:Object(s.a)(l,(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"blog-file-detail",on:{click:t.showImage}},[n("mavon-editor",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"md",attrs:{subfield:!1,"toolbars-flag":!1,"box-shadow":!1,ishljs:!0},domProps:{innerHTML:t._s(t.handbook)}}),n("Dialog",{attrs:{visible:t.visible,width:"66%"},on:{"update:visible":function(e){t.visible=e}}},[[n("img",{attrs:{src:t.currentUrl,alt:""}})]],2)],1)}),[],!1,null,"40f37b8f",null).exports},data:function(){return{asideNavListData:[],currentFilePath:"",interval:null,scrollStop:!0}},computed:{themeClass:function(){return this.$store.state.themeClass}},mounted:function(){var t,e,o,i,r,s=this;setTimeout((function(){s.globalLoading(!1)}),a.a),this.asideNavListData=(i=n("9a51"),r=[],i.keys().forEach((function(t,e){var n=t.replace(/(.\/)([\u4e00-\u9fa5_a-zA-Z0-9+]+)(\/.+)/,"$2"),o=t.replace(/(\.\/|\.md)/g,""),a=t.replace(/(.*\/)*([^.]+).*/gi,"$2");r.length?r.forEach((function(t){r.some((function(t){return t.label===n}))&&t.label===n&&t.list.push({path:o,fileName:a}),r.some((function(t){return t.label===n}))||r.push({label:n,list:[{path:o,fileName:a}]})})):r.push({label:n,list:[{path:o,fileName:a}]})})),t=r,e=a.d,o=[],t.length&&e.length?(e.forEach((function(e,n){t.forEach((function(t){e===t.label&&o.push(t)}))})),o):[])},methods:{switchLael:function(t){this.asideNavListData=this.asideNavListData.map((function(e){return t===e.label?e.isFold=!e.isFold:e.isFold=!1,e}))},scrollHandle:function(t){var e=t.target.scrollTop;e>this.oldScrolltop?o.a.$emit("scroll",!1):o.a.$emit("scroll",!0),this.oldScrolltop=e,null===this.interval?this.interval=setInterval(this.scrollStopFn,900):this.scrollStop=!1},getFileDetail:function(t,e){this.currentFilePath=t,o.a.$emit("set-fine-name",e),Object(i.e)(this.$refs.detailContainer)},scrollStopFn:function(){clearInterval(this.interval),this.scrollStop=!0,this.interval=null}}},u=(n("42bf"),Object(s.a)(p,(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"blog-technology",class:t.themeClass},[n("div",{staticClass:"technology-aside"},t._l(t.asideNavListData,(function(e,o){return n("div",{key:o,staticClass:"aside-nave"},[n("div",{staticClass:"nave-label",on:{click:function(n){return t.switchLael(e.label)}}},[n("span",{staticClass:"nave-label-status"},[n("svg-icon",{staticClass:"icon-status",attrs:{"icon-class":e.isFold?"up":"down"}})],1),n("span",{staticClass:"nave-label-value"},[t._v(t._s(e.label))])]),n("transition-group",{staticClass:"item-file-container",attrs:{name:"aside",tag:"ul"}},t._l(e.list,(function(o,a){return n("li",{directives:[{name:"show",rawName:"v-show",value:e.isFold,expression:"element.isFold"}],key:a,staticClass:"file-name",on:{click:function(e){return t.getFileDetail(o.path,o.fileName)}}},[t._v(" "+t._s(o.fileName)+" ")])})),0)],1)})),0),n("div",{staticClass:"technology-main-content"},[n("div",{ref:"detailContainer",staticClass:"technology-detail",class:{"scroll-show":!t.scrollStop},on:{"&scroll":function(e){return n=e,t.scrollHandle(n);var n}}},[n("file-detail",{attrs:{"file-path":t.currentFilePath}})],1)]),n("div",{staticClass:"detail-nave"},[t._v("详情页导航")])])}),[],!1,null,"cc699984",null));e.default=u.exports},c5e9:function(t,e){t.exports='<h3 id="小程序项目分享">小程序项目分享</h3> <h5 id="一、知识点：">一、知识点：</h5> <p>​ 1、vant 组件库的按需引入方法。</p> <p>​ 2、微信小程序 from 表单的使用</p> <p>​ 3、关于购物车价格计算</p> <p>​ 4、关于微信小程序的时间戳</p> <p>二、问题点</p> <p>​ 1、事件通道怎么用</p> <p>​ 2、微信小程序的路由守卫怎么用</p> '},c5f2:function(t,e){t.exports='<h3 id="vue中的路由监听与vuex组合使用">vue中的路由监听与vuex组合使用</h3> <h5 id="关于-vue-中的路由监听【watch】、vuex中的数值监听组合使用">关于 vue 中的路由监听【watch】、vuex中的数值监听组合使用</h5> <h5 id="1、route-路由监听用法：">1、$route 路由监听用法：</h5> <p>​ 可以在页面公用组件的情况下，通过监听路由，判断当前是在那个页面。</p> <h5 id="总结：">总结：</h5> <p>​ $route 是一个对象，他里面的数据有当前路由里面的数据，同时记录路由的变化情况</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-7a0257560cbf139a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-fa701aa4fcee902e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="2、vuex-中的数值监听方法">2、vuex 中的数值监听方法</h5> <pre><code class="language-js">watch:{\n    // 监听 vuex 里面 posterDefault 的值得变化写法\n    &quot;$store.state.posterDefault&quot;( newValue,oldValue ){\n        this.imageUrl = newValue\n    }\n}\n\n// 由于 &quot;$store.state.posterDefault&quot; 是基本类型的数据，因此不需要使用深度监控。</code></pre> '},cabe:function(t,e){t.exports='<h1 id="asyncawait-优雅的错误处理方法">async/await 优雅的错误处理方法</h1> <h5 id="一般情况下-asyncawait-在错误处理方面，主要使用-trycatch，像这样。">一般情况下 async/await 在错误处理方面，主要使用 <code>try/catch</code>，像这样。</h5> <pre><code class="language-javascript">const fetchData = () =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve(&#39;fetch data is me&#39;)\n        }, 1000)\n    })\n}\n\n(async () =&gt; {\n    try {\n        const data = await fetchData()\n        console.log(&#39;data is -&gt;&#39;, data)\n    } catch(err) {\n        console.log(&#39;err is -&gt;&#39;, err)\n    }\n})()</code></pre> <h5 id="优雅处理方式：">优雅处理方式：</h5> <pre><code class="language-javascript">(async () =&gt; {\n    const fetchData = () =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                resolve(&#39;fetch data is me&#39;)\n            }, 1000)\n        })\n    }\n\n    // 抽离成公共方法，将上面的函数返回结果进行处理\n    const awaitWrap = (promise) =&gt; {\n        return promise\n            .then(data =&gt; [null, data])\n            .catch(err =&gt; [err, null])\n    }\n\n    const [err, data] = await awaitWrap(fetchData())  // 注意这里 awaitwrap 传的参数是一个函数调用\n    console.log(&#39;err&#39;, err)\n    console.log(&#39;data&#39;, data)\n})()</code></pre> <p>参考文档：<a href="https://zhuanlan.zhihu.com/p/79118227">https://zhuanlan.zhihu.com/p/79118227</a></p> '},cf01:function(t,e){t.exports='<h1 id="vue--中常用的事件修饰符">vue 中常用的事件修饰符</h1> <h3 id="1、stop">1、stop</h3> <blockquote> <p>阻止冒泡</p> </blockquote> <pre><code class="language-javascript">&lt;template&gt;\n  &lt;div&gt;\n    事件测试\n    &lt;div class=&quot;father&quot; @click=&quot;fatherFn&quot;&gt;\n      777777777777777777777777777777777\n      &lt;button @click.stop=&quot;sonFn&quot;&gt;按钮&lt;/button&gt;    // 如果不加 stop 两个事件都会触发\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  methods: {\n    fatherFn () {\n      console.log(&#39;fatherFn&#39;)\n    },\n    sonFn () {\n      console.log(&#39;sonFn&#39;)\n    }\n  }\n}\n&lt;/script&gt;</code></pre> <h3 id="2、capture">2、capture</h3> <blockquote> <p>捕获冒泡，即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。</p> </blockquote> <h3 id="2、prevent">2、prevent</h3> <blockquote> <p>阻止默认事件</p> </blockquote> <pre><code class="language-javascript">&lt;form action=&quot;baidu&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&quot;submitClick&quot;&gt;    //阻止 submit 默认事件\n&lt;/form&gt;\n\nsubmitClick () {\n   console.log(&#39;submitClick&#39;)\n}</code></pre> <h3 id="3、keycode--keyalias">3、keyCode | keyAlias</h3> <blockquote> <p>只有触发特定的键盘按键时才触发</p> </blockquote> <pre><code class="language-javascript">&lt;input type=&quot;text&quot; @keyup.enter=&quot;inputKeyUp&quot;&gt;\n\ninputKeyUp (e) {\n    console.log(&#39;inputKeyUp&#39;, e)\n}</code></pre> <h3 id="4、once">4、once</h3> <blockquote> <p>事件只触发一次</p> </blockquote> <pre><code class="language-javascript">&lt;button @click.once=&quot;clickOnce&quot;&gt;点我&lt;/button&gt;\n\nclickOnce () {\n    console.log(&#39;clickOnce&#39;)\n}</code></pre> <h3 id="5、slef">5、slef</h3> <blockquote> <p>将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响</p> </blockquote> <h3 id="6、native">6、native</h3> <blockquote> <p>在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加&#39;. native&#39;事件是无法触 发的。</p> <p>可以理解为该修饰符的作用就是把一个<a href="https://www.baidu.com/s?wd=vue&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">vue</a>组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。</p> </blockquote> <p>参考稳定：<a href="https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html">https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html</a></p> '},d0e2:function(t,e){t.exports='<h3 id="五种循环遍历的方法">五种循环遍历的方法</h3> <h5 id="1、for循环：常用于数组遍历">1、for循环：常用于数组遍历</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-494c1b6668ac3c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="2、foreach--与-for循环作用类似">2、forEach 与 for循环作用类似</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-cc8d25115e8235c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="3、for-in---常用于对象元素遍历">3、for in : 常用于对象元素遍历</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-01e46b88156cbb01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="4、filter-：-数组条件筛选-filter方法不能改变元素的值，需要改变元素的值，只能用map方法-">4、filter ： 数组条件筛选( filter方法不能改变元素的值，需要改变元素的值，只能用map方法 )</h5> <p>​ 更多的用于对数组的元素（对象）进行有条件的筛选。</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-525a94f9ec8a468a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="5、es6的-find--findindex-方法">5、ES6的 find / findIndex 方法</h5> <pre><code class="language-js">var stu = [\n        {\n            name: &#39;张三&#39;,\n            gender: &#39;男&#39;,\n            age: 20\n        },\n        {\n            name: &#39;王小毛&#39;,\n            gender: &#39;男&#39;,\n            age: 20\n        },\n        {\n            name: &#39;李四&#39;,\n            gender: &#39;男&#39;,\n            age: 20\n        }\n    ]\n\n    let temp = stu.find(element =&gt; {\n        return element.name == &#39;李四&#39;\n    })\n\n    let ind = stu.findIndex( elem =&gt; {\n        return elem.name == &#39;李四&#39;\n    } )\n    console.log(temp)        // 返回元素（是个对象）\n    console.log(ind)        // 返回的是下标</code></pre> '},d3ea:function(t,e){t.exports='<h1 id="vue中的全局变量和vueprototype的理解">vue中的全局变量和Vue.prototype的理解</h1> <h5 id="一、使用vueprototype实现全局变量">一、使用Vue.prototype实现全局变量</h5> <p>​ 对于一个vue脚手架项目来说，在main.js里使用Vue.prototype声明的变量，实际上是为Vue对象添加了一个原型属性，而不是一个全局变量。但是如果这个原型属性的值是引用类型的，我们就可以借此实现全局变量。当你在main.js里声明了Vue.prototype.a = 1后，因为你的每一个vue组件都是一个Vue对象的实例，所以即使你没有在组件内部使用data(){return{……}}声明a，你依然可以在组件中通过this.a来访问。 当然，你也可以在组件中添加一个变量a，这时你访问的就是你在组件中添加的a，而不再是之前在原型中添加的a了，当然你对组件的a继续修改即不会影响原型中的a和其他组建中的a。</p> <h5 id="二、在根节点中创建变量来实现全局变量">二、在根节点中创建变量来实现全局变量</h5> <p>​ 当然还有另外一种方法也可以实现vue的全局变量，那就是在根组件中创建这个变量，这样在子组件中就可以通过$root.xxx来访问这个变量了。</p> <p>在main.js里通过</p> <pre><code class="language-js">new Vue({\n  ……\n  data(){\n      return{\n          a:1\n      }\n  },\n ……\n})</code></pre> <p>声明，然后在所有子组件中都可以通过<code>$root.a</code>访问到相同的变量。</p> <h5 id="三、使用vuex">三、使用vuex</h5> <p>​ <a href="https://vuex.vuejs.org/zh/guide/">vuex官方文档</a></p> <h5 id="四、参考文档">四、参考文档</h5> <p>​ <a href="https://blog.csdn.net/pma934/article/details/86765722">https://blog.csdn.net/pma934/article/details/86765722</a></p> '},d784:function(t,e,n){"use strict";n("ac1f");var o=n("6eeb"),a=n("d039"),i=n("b622"),r=n("9263"),s=n("9112"),l=i("species"),p=!a((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")})),u="$0"==="a".replace(/./,"$0"),c=i("replace"),d=!!/./[c]&&""===/./[c]("a","$0"),g=!a((function(){var t=/(?:)/,e=t.exec;t.exec=function(){return e.apply(this,arguments)};var n="ab".split(t);return 2!==n.length||"a"!==n[0]||"b"!==n[1]}));t.exports=function(t,e,n,c){var m=i(t),h=!a((function(){var e={};return e[m]=function(){return 7},7!=""[t](e)})),f=h&&!a((function(){var e=!1,n=/a/;return"split"===t&&((n={}).constructor={},n.constructor[l]=function(){return n},n.flags="",n[m]=/./[m]),n.exec=function(){return e=!0,null},n[m](""),!e}));if(!h||!f||"replace"===t&&(!p||!u||d)||"split"===t&&!g){var v=/./[m],q=n(m,""[t],(function(t,e,n,o,a){return e.exec===r?h&&!a?{done:!0,value:v.call(e,n,o)}:{done:!0,value:t.call(n,e,o)}:{done:!1}}),{REPLACE_KEEPS_$0:u,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:d}),b=q[0],w=q[1];o(String.prototype,t,b),o(RegExp.prototype,m,2==e?function(t,e){return w.call(t,this,e)}:function(t){return w.call(t,this)})}c&&s(RegExp.prototype[m],"sham",!0)}},d995:function(t,e){t.exports=""},d9a8:function(t,e){t.exports='<h3 id="vue-filters-常用功能">vue filters 常用功能</h3> <h5 id="vue-filters-常用功能（时间戳转换成指定格式、金额保留两位小数）">vue filters 常用功能（时间戳转换成指定格式、金额保留两位小数）</h5> <pre><code class="language-javascript">filters: {\n    fomatDate(time) {\n      let date = new Date(time);\n      let Y = date.getFullYear();\n      let M = date.getMonth() + 1;\n      let D = date.getDate();\n      return `${Y}年-${M}月-${D}日`;\n    },\n    formatTime(time) {\n      let date = new Date(time);\n      let Y = date.getFullYear();\n      let M = date.getMonth() + 1;\n      let D = date.getDate();\n      let h = date.getUTCHours();\n      let m = date.getMinutes();\n      let s = date.getSeconds();\n      let f = num =&gt; (num &lt; 10 ? &quot;0&quot; + num : num);\n      return `${f(Y)}-${f(M)}-${f(D)} ${f(h)}:${f(m)}:${f(s)}`;\n    },\n    // 金额保留两位小数\n    formatMoney(num) {\n      return (num / 100).toFixed(2);\n    }\n  }</code></pre> '},ea63:function(t,e){t.exports='<h3 id="webpack-的使用">webpack 的使用</h3> <h5 id="一、目录">一、目录</h5> <ol> <li>入口和出口是什么</li> <li>配置文件webpack.config.js</li> <li>mode设置(模式设置)</li> <li>打包命令webpack</li> </ol> <h5 id="二、基础流程">二、基础流程</h5> <ol> <li>新建文件夹demo1.0</li> <li>初始化package.json <code>npm init -y</code></li> <li>新建main.js,m1.js,m2.js</li> </ol> <pre><code class="language-js">// main.js\nconst m1 = require(&#39;./m1&#39;);\n\nconsole.log(&#39;main.js&#39;);\n// m1.js\nconst m2 = require(&#39;./m2&#39;);\nconsole.log(&#39;我是m1.....&#39;);\n\n// m2.js\nconsole.log(&#39;我是m2.</code></pre> <p>4.webpack配置文件</p> <pre><code>// 导入nodejs的path\nconst path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口配置\n    entry: &#39;./main.js&#39;,\n    // 出口配置\n    output: {\n        // 打包后的文件名称\n        filename: &#39;laohu.js&#39;,\n        // 配置打包后的路径,__dirname当前目录,\n        path: path.resolve(__dirname, &#39;dist&#39;)\n    },\n    mode: &#39;production&#39;\n}</code></pre><p>5.运行webpack,打包成功会在本地创建一个dist文件夹,里面有一个laohu.js</p> <h5 id="三、loader配置">三、loader配置</h5> <p>​ loader是什么？</p> <p>​ 在webpack眼里,一切皆模块,js、css、img、txt、vue等统统都是模块，但webpack默认只认识js模块，其它文件都需要配置相应的加载器（loader）才能正确的识别，比如css要配css-loader，vue要配vue-loader</p> <ol> <li>安装less 和 less-loader(可以批量安装)</li> </ol> <pre><code class="language-text">npm install --save-dev less-loader less style-loader css-loader</code></pre> <p>​ 2.webpack配置 【 注意：这里的 style-loader / css-loader / less-loader 书写有顺序要求】</p> <pre><code class="language-javascript">// path是nodejs的路径处理插件\nconst path = require(&#39;path&#39;);\nmodule.exports = {\n    // 模式 production-生产环境  development-开发环境\n    mode: &#39;development&#39;,\n    // 入口\n    entry: &#39;./main.js&#39;,\n    // 出口\n    output: {\n        path: path.resolve(__dirname, &#39;dist&#39;),\n        filename: &#39;index.js&#39;\n    },\n    module: {\n        rules: [{\n            test: /\\.less$/,\n            use: [{\n                loader: &quot;style-loader&quot; // creates style nodes from JS strings\n            }, {\n                loader: &quot;css-loader&quot; // translates CSS into CommonJS\n            }, {\n                loader: &quot;less-loader&quot; // compiles Less to CSS\n            }]\n        }]\n    }\n  };</code></pre> <p>​ 3.新建main.js和app.less</p> <pre><code class="language-javascript">// main.js\nrequire(&#39;./app.less&#39;);\nconsole.log(&#39;在这里做的别的事情&#39;)\n// app.less\n\ndiv {\n    h3 {\n        color: red;\n        font-size: 30px\n    }\n}</code></pre> <p>​ 4.检验:在dist文件夹新建index.html,导入打开看看h3是否变了颜色</p> <pre><code class="language-javascript">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;h3&gt;\n            这是h3\n        &lt;/h3&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre> <h5 id="四、plugins插件">四、plugins(插件)</h5> <ol> <li><p>插件是什么,有什么用</p> </li> <li><p>配置生成html的插件</p> </li> <li><p>定义全局变量的插件</p> </li> <li><p>安装html-webpack-plugin</p> </li> </ol> <pre><code class="language-text">npm i html-webpack-plugin</code></pre> <p>​ 2.webpack.config.js的配置如下</p> <p> 最简单的配置</p> <pre><code class="language-javascript">const path = require(&#39;path&#39;);\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = {\n    mode: &#39;development&#39;,\n    entry: &#39;./main.js&#39;,\n    output: {\n        path: path.resolve(__dirname, &#39;dist&#39;),\n        filename: &#39;main-webpack.js&#39;\n    },\n    plugins: [new HtmlWebpackPlugin()]\n  };</code></pre> <p> 用指定的模板生成html文件</p> <pre><code class="language-javascript">const path = require(&#39;path&#39;);\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = {\n    mode: &#39;development&#39;,\n    entry: &#39;./main.js&#39;,\n    output: {\n        path: path.resolve(__dirname, &#39;dist&#39;),\n        filename: &#39;main-webpack.js&#39;\n    },\n    plugins: [\n      new HtmlWebpackPlugin({\n          filename: &#39;index.html&#39;,\n          template: &#39;./tpl.html&#39;\n        })\n    ]\n  };</code></pre> <p>// tpl.html内容</p> <pre><code class="language-javascript">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;vue项目&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre> <p><a href="http://huruqing.cn/docs/Webpack/list/demo03.html#%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%8F%92%E4%BB%B6">#</a>配置生成全局变量的插件</p> <ol> <li>安装html-webpack-plugin和webpack</li> </ol> <pre><code class="language-text">npm i html-webpack-plugin webpack</code></pre> <ol> <li>webpack.config.js配置</li> </ol> <pre><code class="language-javascript">const webpack = require(&#39;webpack&#39;);\nconst htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nconst path = require(&#39;path&#39;);\nmodule.exports = {\n    // 模式 production-生产环境  development-开发环境\n    mode: &#39;development&#39;,\n    // 入口\n    entry: &#39;./main.js&#39;,\n    // 出口\n    output: {\n        path: path.resolve(__dirname, &#39;dist&#39;),\n        filename: &#39;main-webpack.js&#39;\n    },\n    plugins:[\n        new htmlWebpackPlugin(),\n        new webpack.DefinePlugin({\n            // 值是字符串的时候需要多加一个引号\n            &#39;username&#39;: &#39;&quot;老胡&quot;&#39;,\n            &#39;process.env.baseUrl&#39;: &#39;&quot;http://huruqing.cn&quot;&#39;\n        })\n    ]\n  };</code></pre> <ol> <li>main.js内容</li> </ol> <pre><code class="language-text">console.log(&#39;useranme:&#39;,username);\nconsole.log(&#39;baseUrl:&#39;,process.env.baseUrl);</code></pre> <ol> <li>运行webpack打包命令,打开dist里的index.html文件,检查控制台的打印结果</li> </ol> <h5 id="五、webpack-dev-server配置">五、webpack-dev-server配置</h5> <ol> <li><p>安装相关模块webpack,webpack-cli,webpack-dev-server都需要全局安装</p> <pre><code class="language-js">npm i webpack webpack-cli html-webpack-plugin webpack-dev-server</code></pre> </li> <li><p>main.js代码</p> <pre><code class="language-text">document.body.innerHTML = &#39;&lt;h3&gt;webpack-dev-server&lt;/h3&gt;&#39;</code></pre> </li> <li><p>webpack.config.js代码</p> <pre><code class="language-javascript">const path = require(&#39;path&#39;);\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = {\n    mode: &#39;development&#39;,\n    entry: &#39;./main.js&#39;,\n    output: {\n        path: path.resolve(__dirname, &#39;dist&#39;),\n        filename: &#39;main-webpack.js&#39;\n    },\n    plugins: [new HtmlWebpackPlugin()],\n    devServer: {\n      contentBase: path.join(__dirname, &quot;dist&quot;),\n      compress: true,\n      open:true, //是否自动打开默认浏览器\n      port: 9000 // 端口号\n    }\n  };</code></pre> </li> <li><p>运行 webpack-dev-server</p> </li> </ol> <h5 id="六、resolve别名配置和文件后缀配置">六、resolve别名配置和文件后缀配置</h5> <ol> <li><p>main.js 代码</p> <pre><code class="language-javascript">import {add} from &#39;@/cart&#39;\nadd();</code></pre> </li> <li><p>/src/cart.js 代码</p> <pre><code class="language-javascript">export const add = ()=&gt; {\n  let divEle = document.createElement(&#39;div&#39;);\n  divEle.innerText = &#39;我是购物车模块&#39;;\n  document.body.appendChild(divEle);\n}</code></pre> </li> <li><p>webpack.config.js 代码</p> <pre><code class="language-javascript">// 导入nodejs的path\nconst path = require(&#39;path&#39;);\nconst htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\n\nmodule.exports = {\n    // 入口配置\n    entry: &#39;./main.js&#39;,\n    // 出口配置\n    output: {\n        // 打包后的文件名称\n        filename: &#39;bundle.js&#39;,\n        // 配置打包后的路径,__dirname当前目录,\n        path: path.resolve(__dirname, &#39;dist&#39;)\n    },\n    mode: &#39;development&#39;,\n    plugins: [\n      new htmlWebpackPlugin()\n    ],\n    resolve:{\n      alias:{\n        &#39;@&#39;: path.resolve(__dirname,&#39;src&#39;)\n      },   \n      // 省略后缀名\n      extensions: [\n       &#39;.mjs&#39;,\n       &#39;.js&#39;,\n       &#39;.jsx&#39;,\n       &#39;.vue&#39;,\n       &#39;.json&#39;,\n       &#39;.wasm&#39;\n     ],\n    }\n}</code></pre> </li> </ol> <h5 id="七、跨域配置">七、跨域配置</h5> <p>对dev-server进行一下设置,详见vue-cli3配置跨域</p> <pre><code class="language-javascript">devServer: {\n  // 代理\n  proxy: {\n    // 只要请求地址有&#39;api&#39;都会匹配上\n    &quot;/api&quot;: {\n      target: &quot;http://127.0.0.1:3006&quot;,\n      ws: true,\n      // 允许跨域\n      changeOrigin: true,\n      pathRewrite: {\n        &quot;^/api&quot;: &quot;&quot; //通过pathRewrite重写地址，将前缀/api转为/\n      }\n    }\n  }\n}    </code></pre> <h5 id="八、vue-cli3的webpack配置">八、vue-cli3的webpack配置</h5> <p>vue-cli3搭建项目用的也是webpack,不过配置文件在vue-cli2.x是可见的,3.x就隐藏起来了,需要查看vue-cli3的配置文件,可以使用vue-cli3创建一个新的项目,然后执行以下命令</p> <ol> <li><p>进入到项目根目录,执行 vue inspect 就能查看webpack配置</p> </li> <li><p>输出配置文件</p> <pre><code class="language-text">vue inspect &gt; webpack.config.js</code></pre> </li> </ol> '},ea8f:function(t,e){t.exports='<h3 id="vue-中-iconfont-字体图标使用的两种方法">vue 中 iconfont 字体图标使用的两种方法</h3> <h5 id="方法一：">方法一：</h5> <p>1、获取图标【 注意当添加新图标时以下内容需要更换 】</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-f94b0db2282ff7d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>​ 可以将该代码放在css 的 common 样式中</p> <p>2、定义使用iconfont的样式（该步骤是固定的）【 注意当添加新图标时以下内容不需要更换 】</p> <pre><code class="language-js">.iconfont{\n    font-family:&quot;iconfont&quot; !important;\n    font-size:16px;font-style:normal;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;}</code></pre> <p>​ 可以将该代码放在css 的 common 样式中</p> <p>3、挑选相应图标并获取字体编码，应用于页面</p> <pre><code class="language-js">&lt;i class=&quot;iconfont&quot;&gt;&amp;#x33;&lt;/i&gt;\n\n// 注意需要 iconfont 类名</code></pre> <h5 id="方法二：">方法二：</h5> <p>1、获取图标连接</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-b57fdac66fe94c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>2、引入图标链接到 vue</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-0b89b3caeece837a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>3、挑选相应图标并获取字体编码，应用于页面</p> <pre><code class="language-js">&lt;i class=&quot;iconfont&quot;&gt;&amp;#x33;&lt;/i&gt;\n\n// 注意需要 iconfont 类名</code></pre> '},ef95:function(t,e){t.exports='<h3 id="vue中关于插槽的理解">vue中关于插槽的理解</h3> <h4 id="一、slot-插槽【-父组件的内容插入到子组件里面去-】">一、slot 插槽【 父组件的内容插入到子组件里面去 】</h4> <h5 id="单个插槽：">单个插槽：</h5> <p>​ 父组件：引入 demo ----》 注册 demo ----》使用 demo</p> <pre><code class="language-vue">&lt;template&gt;\n    &lt;div&gt;\n        影院\n        &lt;demo&gt;\n            &lt;p&gt;所有过往结尾序章&lt;/p&gt;        // 写在子组件里面的\n        &lt;/demo&gt;\n        &lt;FootNave&gt;&lt;/FootNave&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre> <p>​ 子组件：</p> <pre><code class="language-vue">&lt;template&gt;\n    &lt;div class=&quot;childrens&quot;&gt;\n        影院子组件\n        &lt;slot&gt;        // 不写 slot 则组组件的 p 标签里面的值不会显示\n            2142552165135    // 在 slot(父) 插入了内容则子组件里面的值会被替换掉，否则会显示该内容\n        &lt;/slot&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre> <h5 id="多个插槽【-也叫具名插槽-】：">多个插槽【 也叫具名插槽 】：</h5> <p>​ 父组件：引入 demo ----》 注册 demo ----》使用 demo</p> <pre><code class="language-vue">&lt;template&gt;\n    &lt;div&gt;\n        影院\n        &lt;demo&gt;\n            &lt;p slot=&quot;slot1&quot;&gt;所有过往结尾序章1&lt;/p&gt;\n            &lt;p slot=&quot;slot2&quot;&gt;所有过往结尾序章2&lt;/p&gt;\n            &lt;p slot=&quot;slot3&quot;&gt;所有过往结尾序章3&lt;/p&gt;\n        &lt;/demo&gt;\n        &lt;FootNave&gt;&lt;/FootNave&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre> <p>​ 子组件：</p> <pre><code class="language-vue">&lt;template&gt;\n    &lt;div class=&quot;childrens&quot;&gt;\n        影院子组件\n        &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;        // 子组件会根据父组件插槽的 name 属性来填充\n        &lt;slot name=&quot;slot3&quot;&gt;&lt;/slot&gt;\n        &lt;slot name=&quot;slot2&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre> <h4 id="二、子组件向父组件传值用到的作用域插槽：">二、子组件向父组件传值用到的作用域插槽：</h4> <h5 id="子组件设置：">子组件设置：</h5> <pre><code class="language-vue">&lt;template&gt;\n    &lt;div&gt;\n        影院子组件\n        &lt;slot :listss=&quot;list&quot;&gt;&lt;/slot&gt;  //这里的 listss 是一个自定义属性，list 是 data 里面的数据\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    data(){\n        return {\n            list:[\n                {\n                    name:&quot;张三&quot;,\n                    age:19\n                },\n                {\n                    name:&quot;李四&quot;,\n                    age:22\n                },\n                {\n                    name:&quot;王五&quot;,\n                    age:25\n                }\n            ]\n        }\n    }\n}\n&lt;/script&gt;</code></pre> <h5 id="父组件设置（接收子组件传过来的值）：">父组件设置（接收子组件传过来的值）：</h5> <pre><code class="language-vue">// 引入 demo ----》 注册 demo ----》使用 demo\n\n&lt;template&gt;\n    &lt;div&gt;\n        影院\n        &lt;demo&gt;\n            // ----》 slot-scope 用于接收子组件传过来的值\n            &lt;ul slot-scope=&quot;scores&quot;&gt;  // 也可以用一个 template 标签包起来\n                // ----》 scores.listss 获取子组件传过来的 listss \n                &lt;li v-for=&quot;(item,index) in scores.listss&quot; :key=&quot;index&quot;&gt;\n                    {{item.name}}:{{item.age}}\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/demo&gt;\n        &lt;FootNave&gt;&lt;/FootNave&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre> '},f3e6:function(t,e){t.exports='<h3 id="数组操作常用的方法">数组操作常用的方法</h3> <h5 id="1、数组去重推荐使用-set方法">1、数组去重推荐使用 set()方法</h5> <pre><code class="language-javascript">var arr = [1, 2, 8, 4, 5, 6, 3, 2, 1, 1, 2]\n// 方法一：\nlet resultArr = []\narr.forEach((item,index) =&gt; {\n    if( !resultArr.includes(item) ) {\n        resultArr.push(item)\n    }\n})\nconsole.log( resultArr )\n\n// 方法二：\nlet resultArr2 = []\narr.forEach((item,index,arr) =&gt; {\n    if( arr.indexOf(item) == index ) {\n        resultArr2.push( item )\n    }\n})\nconsole.log( resultArr2 )\n\n// 方法三：\nlet resultArr3 = Array.from( new Set( arr ) )\nconsole.log( &quot;resultArr3&quot;,resultArr3 )</code></pre> <h5 id="2、filter-筛选数组对象">2、filter() 筛选数组对象</h5> <p>​ 注意：filter方法只能筛选数组元素，不能改变数组元素的内容（注意与map的区别）</p> <pre><code class="language-javascript">filter() 去掉空字符串、undefined、null\n\nlet arr = [&#39;&#39;,&#39;1&#39;,&#39;2&#39;,undefined,&#39;3.jpg&#39;,null]\nlet newArr = arr.filter(item =&gt; item)    // return 条件为true的元素\nconsole.log(newArr)</code></pre> <h5 id="3、-map和foreach等遍历方法不同">3、 map和forEach等遍历方法不同</h5> <p>​ 在forEach中return语句是没有任何效果的，而map则<strong>可以改变当前循环的值，返回一个新的被改变过值之后的数组（map需return）</strong>，一般用来处理需要修改某一个数组的值。如果需要改变数组对象中的元素，一般需要配合拓展运算符（...）</p> <pre><code class="language-javascript">//微信小程序项目\nlet url = &quot;/cart/updateNum&quot;\napp.$get( url,data ).then(res =&gt; {\n    console.log( res )\n    console.log(this.data.cartList[0].buyNum)\n    if(res.code === 666){\n        let tempArr = this.data.cartList.map(item =&gt; {\n            if( item.cartId == cartid ){\n                return {\n                    ...item,\n                    buyNum:detail            //步进器更新购买数量\n                    //也可在此添加一个 item 中不存在的属性如（ checked:true ）\n                }\n            }else{\n                return item\n            }\n        })\n        // 修改数量成功后需要重新计算合计价格\n        this.setData({\n            cartList:tempArr,\n            totalMoney:this.getTotalMoney( tempArr )\n        })\n    }\n}).catch(err =&gt; {\n    console.log( err )\n})</code></pre> <h5 id="4、splice方法【数组的删除或者添加元素】">4、splice方法【数组的删除或者添加元素】</h5> <p>​ splice（index ，howmany，item1，...，item1） <strong>返回的是删除的元素形成的一个数组</strong></p> <p><img src="C:%5CUsers%5CTHINK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566541745244.png" alt="1566541745244"></p> <pre><code class="language-javascript">let filtratedArr = this.data.cartList\nfor( let i = 0 ; i &lt; filtratedArr.length ; i++ ){\n    for( let j = 0 ; j &lt; cartIdArr.length ; j++ ){\n        if( filtratedArr[i].cartId == cartIdArr[j] ){\n            filtratedArr.splice(i,1)\n        }\n    }\n}\nconsole.log( filtratedArr )\nthis.setData({\n    cartList:filtratedArr,\n    selectArr:[],\n    selectAll:false\n})\n// 可能还有更好的方法，目前没找到。</code></pre> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-a3b73e4dcda0ae5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h5 id="5、slice--splice--split-方法的区别">5、slice / splice / split 方法的区别</h5> <pre><code class="language-javascript">slice(start,end)        // 数组的截取\nsplic(index ，howmany，item1，...，item1)    // 数组同时删除并修改（添加）某个（或几个）元素\nsplit【 字符串方法 】                    // 根据分割符，将字符串转化成数组</code></pre> <h5 id="6、reduce-方法">6、reduce 方法</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-8391718acdb11467.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <pre><code class="language-javascript">// 数组求和（ 数组元素只能是数字 ）\nlet arr = [4,6,1,8,6]\nlet res = arr.reduce((sum,item,index) =&gt; {\n    return sum + item\n})\nconsole.log( res )</code></pre> <p>​ 1》、项目应用：</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-38da9728dcf5eae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>​ 2》、将数组转换成对象：</p> <pre><code class="language-javascript">const userList = [\n    {\n        id: 1,\n        username: &#39;john&#39;,\n        sex: 1,\n        email: &#39;john@163.com&#39;\n    },\n    {\n        id: 2,\n        username: &#39;jerry&#39;,\n        sex: 1,\n        email: &#39;jerry@163.com&#39;\n    },\n    {\n        id: 3,\n        username: &#39;nancy&#39;,\n        sex: 0,\n        email: &#39;&#39;\n    }\n    ];\n\n    let result = userList.reduce((pre, current) =&gt; {\n        return {...pre, [current.id]: current};  // 类似于数组的 push 方法\n    }, {});\n    console.log(result)</code></pre> <p>​ 3》、求数组的最大值与最小值</p> <pre><code class="language-javascript">const readings = [7,2,5,7,1,4,6,9];\n\nlet minValue = readings.reduce((x,y) =&gt; Math.min(x,y));\nconsole.log(minValue);\n\nlet maxValue = readings.reduce((x,y) =&gt; Math.max(x,y));\nconsole.log(maxValue)</code></pre> <h5 id="7、filter--includes-过滤数组">7、filter + includes 过滤数组</h5> <p>​ 简单demo：</p> <pre><code class="language-javascript">// 从 arr01 中删除含有 arr02 中的元素\nlet arr01 = [9,2,5,2,8,9,&#39;a&#39;,&#39;b&#39;,2,6]\nlet arr02 = [5,9]\nlet arr03 = arr01.filter(item =&gt; {\n    return !arr02.includes(item)\n})\nconsole.log( arr03 )        // [2, 2, 8, &quot;a&quot;, &quot;b&quot;, 2, 6]</code></pre> <p>​ vue 项目应用案例：购物车勾选删除</p> <pre><code class="language-javascript">this.cartList = this.cartList.filter(item =&gt; {\n    return !cartId.includes(item.cartId);\n})</code></pre> <h5 id="8、arraysome-方法用法">8、Array.some() 方法用法</h5> <p><strong>some()</strong> 方法测试数组中的 <strong>某些元素</strong> 是否通过了指定函数的测试。</p> <p>定义和用法： some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p> <p>some() 方法会依次执行数组的每个元素：</p> <p>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 注意： some() 不会对空数组进行检测。</p> <p>注意： some() 不会改变原始数组。</p> <h5 id="语法">语法</h5> <blockquote> <p>array.some(function(currentValue,index,arr),thisValue)</p> <p>function(currentValue, index,arr) 必须。函数，数组中的每个元素都会执行这个函数函数参数:</p> <h5 id="参数描述：">参数描述：</h5> <p>currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值。如果省略了 thisValue ，&quot;this&quot; 的值为 &quot;undefined&quot;</p> </blockquote> <h5 id="用法示例：">用法示例：</h5> <pre><code class="language-javascript">// 1、用于判断数组中的元素是否有符合条件的\nvar ages = [23, 44, 3]\nif (ages.some(age =&gt; age &lt; 10)) {    // 这里的 ages.some(age =&gt; age &lt; 10) 结果为布尔值\n    console.log(&#39;true666&#39;)\n}\n// 注意：1、some 的回调函数需要 return ，否则得不到预期的结果\n//         2、箭头函数如果函数体只有一行时可以直接简写 age =&gt; age &lt; 10    等价于下面\n        age =&gt; {\n            return age &lt; 10\n        }\n\n//**********************************************************************************\n\n// 2、用于数组遍历：\ncategoryList.some((item) =&gt; {\n    if (item.id === currWorkInfo.categoryId) {\n        defaultCatetoryKey = item.key;\n        currWorkInfo.categoryKey = item.key;\n        return true;\n    }\n    return false;\n});\n\n// *********************************************************************************\n\n// 3、用于判断数组中的元素是否有符合条件的\nfunction isBigEnough(element, index, array) {\n  return (element &gt;= 10);\n}\nvar passed = [2, 5, 8, 1, 4].some(isBigEnough);\n// passed is false\npassed = [12, 5, 8, 1, 4].some(isBigEnough);\n// passed is true</code></pre> <h5 id="9、arrayevery-方法用法">9、Array.every() 方法用法</h5> <p><strong>every()</strong> 方法测试数组的 <strong>所有元素</strong> 是否都通过了指定函数的测试。</p> <h5 id="语法-1">语法</h5> <pre><code>arr.every(callback[, thisArg])</code></pre><h5 id="参数">参数</h5> <ul> <li><p><code>callback</code></p> <p>用来测试每个元素的函数。</p> </li> <li><p><code>thisArg</code></p> <p>执行 <code>callback</code> 时使用的 <code>this</code> 值。</p> </li> </ul> <h5 id="实例：">实例：</h5> <pre><code class="language-javascript">// 检测数组中的元素是否都大于 10\nfunction isBigEnough(element, index, array) {\n  return (element &gt;= 10);\n}\nvar passed = [12, 5, 8, 130, 44].every(isBigEnough);\n// passed is false\npassed = [12, 54, 18, 130, 44].every(isBigEnough);\n// passed is true</code></pre> <h5 id="9、es6的-find--findindex-方法">9、ES6的 find / findIndex 方法</h5> <pre><code class="language-js">var stu = [\n        {\n            name: &#39;张三&#39;,\n            gender: &#39;男&#39;,\n            age: 20\n        },\n        {\n            name: &#39;王小毛&#39;,\n            gender: &#39;男&#39;,\n            age: 20\n        },\n        {\n            name: &#39;李四&#39;,\n            gender: &#39;男&#39;,\n            age: 20\n        }\n    ]\n\n    let temp = stu.find(element =&gt; {\n        return element.name == &#39;李四&#39;\n    })\n\n    let ind = stu.findIndex( elem =&gt; {\n        return elem.name == &#39;李四&#39;\n    } )\n    console.log(temp)        // 返回元素（是个对象）\n    console.log(ind)        // 返回的是下标</code></pre> '},f58e:function(t,e){t.exports='<h1 id="asyncawait-的理解">async/await 的理解</h1> <h3 id="promise-对象的理解：">promise 对象的理解：</h3> <p>​ promise 是一个对象，对象就能用来进行存取数据。存成功用 resolve、存失败用 reject，通过.then/.catch来取数据。</p> <h3 id="1、asyncawait-进行异步处理：">1、async/await 进行异步处理：</h3> <p>​ 其实前面加了async的函数,当我在这个函数调用的时候进行打印发现它输出的是一个promise对象,其实这个函数的本质就是返回了一个promise对象,在这个函数里里我们加上await后,即使调用的是异步代码,它也会变成类似于同步,只有让这个异步代码执行完后,才会执行下面的同步代码来执行，这就是它的本质。</p> <p>​ async与await需要配合使用的，await后面必须跟的是一个 promise 对象。</p> <p>利用定时器模拟 async/await 将异步变同步的问题。</p> <pre><code class="language-javascript">function f1() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log(1)\n            resolve();          // 不写 resolve 为什么后面的代码不执行？不写是语法错误\n        }, 2000)\n    })\n}\nfunction f2() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log(2)\n            resolve(2);\n        }, 5000)\n    })\n}\nfunction f3() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log(3)\n            resolve(3);\n        }, 2000)\n    })\n}\n\nasync function test() {\n    await f1();\n    await f2();\n    await f3();\n}\n\ntest()</code></pre> <h3 id="2、asyncawait-利用trycatch进行错误捕获：">2、async/await 利用try/catch进行错误捕获：</h3> <p>​ async/await 一般是与 try/catch 配合使用来进行错误捕获。否则捕获不到失败，且遇到失败后面的代码就不在执行，也不知道是什么原因。有了 try/catch 就不存在这个问题了。注意，这里的 try/catch 是只要有一个失败，结果就是失败。</p> <p>案例：利用 flag 模拟成功失败。</p> <p>​ 当有一个promise时：</p> <pre><code class="language-javascript">var promise = new Promise((resolve, reject) =&gt; {\n    var flag = false;\n    setTimeout(() =&gt; {\n        if (flag) {\n            resolve({\n                code: 666,\n                msg: &#39;success&#39;\n            })\n        } else {\n            reject({\n                code: 600,\n                msg: &#39;error&#39;\n            })\n        }\n    }, 2000)\n})\n\nasync function test() {\n    try {\n        let res = await promise;    // 在此就能将上面的 promise 关联进来，如果有多个    promise就                                         res1=.../res2=...\n        console.log(res);\n    } catch (error) {\n        console.log(error);\n    }\n    console.log(22222);     // 如果不写 try/catch 22222 是不会打印的，因为上面出错\n}\n\ntest();</code></pre> <p>​ 当有多个promise时：</p> <pre><code class="language-javascript">var promise1 = new Promise((resolve, reject) =&gt; {\n    var flag = true;\n    setTimeout(() =&gt; {\n        if (flag) {\n            resolve({\n                code: 666,\n                msg: &#39;success&#39;\n            })\n        } else {\n            reject({\n                code: 600,\n                msg: &#39;error&#39;\n            })\n        }\n    }, 2000)\n})\nvar promise2 = new Promise((resolve, reject) =&gt; {\n    var flag = true;\n    setTimeout(() =&gt; {\n        if (flag) {\n            resolve({\n                code: 666,\n                msg: &#39;success&#39;\n            })\n        } else {\n            reject({\n                code: 600,\n                msg: &#39;error&#39;\n            })\n        }\n    }, 5000)\n})\n\nasync function test() {\n    try {\n        let res1 = await promise1;    // 在此就能将上面的 promise 关联进来\n        let res2 = await promise2;    // 在此就能将上面的 promise 关联进来\n        console.log(res1);\n        console.log(res2);\n    } catch (error) {\n        console.log(error);\n    }\n    console.log(22222);     // 如果不写 try/catch ,22222 是不会打印的，因为上面出错\n}\n\ntest();</code></pre> <p>参考文档：<a href="https://juejin.im/post/5a9516885188257a6b061d72/">https://juejin.im/post/5a9516885188257a6b061d72/</a></p> '},f8e3:function(t,e){t.exports='<h3 id="卖座城市列表渲染">卖座城市列表渲染</h3> <h5 id="1、获取数据-------》把数据放在本地">1、获取数据-------》把数据放在本地</h5> <h5 id="2、热门城市替换：利用模板字符串">2、热门城市替换：利用模板字符串</h5> <pre><code class="language-js">test.cities[k].isHot == 1          //判断是否是热门城市</code></pre> <h5 id="3、城市列表渲染">3、城市列表渲染</h5> <p>​ 1》、将获取到的数组转换成如下对象</p> <pre><code class="language-js">{B: Array(4), S: Array(11), G: Array(4), L: Array(8), Q: Array(8), …}\nA: (2) [&quot;鞍山&quot;, &quot;阿拉善盟&quot;]\nB: (4) [&quot;北京&quot;, &quot;蚌埠&quot;, &quot;百色&quot;, &quot;白银&quot;]\nC: (6) [&quot;长治&quot;, &quot;长沙&quot;, &quot;长春&quot;, &quot;重庆&quot;, &quot;郴州&quot;, &quot;赤峰&quot;]\nD: [&quot;达州&quot;]\nE: (2) [&quot;鄂州&quot;, &quot;鄂尔多斯&quot;]\nF: (4) [&quot;防城港&quot;, &quot;阜阳&quot;, &quot;阜新&quot;, &quot;福州&quot;]\nG: (4) [&quot;广州&quot;, &quot;赣州&quot;, &quot;贵阳&quot;, &quot;贵港&quot;]\nH: (12) [&quot;黑河&quot;, &quot;黄石&quot;, &quot;黄山&quot;, &quot;黄冈&quot;, &quot;鹤岗&quot;, &quot;邯郸&quot;, &quot;贺州&quot;, &quot;衡阳&quot;, &quot;衡水&quot;, &quot;葫芦岛&quot;, &quot;菏泽&quot;, &quot;红河哈尼族彝族自治州&quot;]\nJ: (5) [&quot;锦州&quot;, &quot;金华&quot;, &quot;酒泉&quot;, &quot;荆门&quot;, &quot;荆州&quot;]\nL: (8) [&quot;龙岩&quot;, &quot;陵水黎族自治县&quot;, &quot;陇南&quot;, &quot;连云港&quot;, &quot;辽阳&quot;, &quot;辽源&quot;, &quot;莱芜&quot;, &quot;聊城&quot;]\nM: (4) [&quot;马鞍山&quot;, &quot;茂名&quot;, &quot;绵阳&quot;, &quot;眉山&quot;]\nP: (3) [&quot;萍乡&quot;, &quot;莆田&quot;, &quot;盘锦&quot;]\nQ: (8) [&quot;齐齐哈尔&quot;, &quot;黔西南布依族苗族自治州&quot;, &quot;黔南布依族苗族自治州&quot;, &quot;黔东南苗族侗族自治州&quot;, &quot;青岛&quot;, &quot;钦州&quot;, &quot;衢州&quot;, &quot;秦皇岛&quot;]\nS: (11) [&quot;上海1&quot;, &quot;深圳&quot;, &quot;韶关&quot;, &quot;随州&quot;, &quot;邵阳&quot;, &quot;遂宁&quot;, &quot;苏州&quot;, &quot;绥化&quot;, &quot;绍兴&quot;, &quot;石家庄&quot;, &quot;石嘴山&quot;]\nT: (5) [&quot;铜陵&quot;, &quot;铜川&quot;, &quot;铜仁&quot;, &quot;铁岭&quot;, &quot;通化&quot;]\nW: [&quot;芜湖&quot;]\nX: (7) [&quot;锡林郭勒盟&quot;, &quot;邢台&quot;, &quot;许昌&quot;, &quot;西安&quot;, &quot;西宁&quot;, &quot;西双版纳傣族自治州&quot;, &quot;襄阳&quot;]\nY: (9) [&quot;鹰潭&quot;, &quot;雅安&quot;, &quot;阳泉&quot;, &quot;阳江&quot;, &quot;银川&quot;, &quot;运城&quot;, &quot;营口&quot;, &quot;盐城&quot;, &quot;益阳&quot;]\nZ: (8) [&quot;驻马店&quot;, &quot;镇江&quot;, &quot;郑州&quot;, &quot;遵义&quot;, &quot;资阳&quot;, &quot;舟山&quot;, &quot;自贡&quot;, &quot;肇庆&quot;]</code></pre> <pre><code class="language-js">// 城市列表替换\n    var obj = {}\n    var arr = test.cities\n    console.log( arr )\n    for( var i = 0 ; i &lt; arr.length ; i++ ){\n        if( obj[ arr[i].pinyin[0].toLocaleUpperCase() ] ){        \n            obj[ arr[i].pinyin[0].toLocaleUpperCase() ].push(  arr[i].name  )\n        }else{\n            obj[ arr[i].pinyin[0].toLocaleUpperCase() ] = [ arr[i].name ]\n        }\n    }\n    console.log( obj )</code></pre> <p>2》、将获取到的对象转换成数组对象（数组的元素是对象）</p> <pre><code class="language-js">0: {key: &quot;B&quot;, value: Array(4)}\n1: {key: &quot;S&quot;, value: Array(11)}\n2: {key: &quot;G&quot;, value: Array(4)}\n3:\nkey: &quot;L&quot;\nvalue: (8) [&quot;龙岩&quot;, &quot;陵水黎族自治县&quot;, &quot;陇南&quot;, &quot;连云港&quot;, &quot;辽阳&quot;, &quot;辽源&quot;, &quot;莱芜&quot;, &quot;聊城&quot;]\n__proto__: Object\n4: {key: &quot;Q&quot;, value: Array(8)}\n5: {key: &quot;H&quot;, value: Array(12)}\n6: {key: &quot;Y&quot;, value: Array(9)}\n7: {key: &quot;Z&quot;, value: Array(8)}\n8: {key: &quot;M&quot;, value: Array(4)}\n9: {key: &quot;A&quot;, value: Array(2)}\n10: {key: &quot;F&quot;, value: Array(4)}\n11: {key: &quot;C&quot;, value: Array(6)}\n12: {key: &quot;J&quot;, value: Array(5)}\n13: {key: &quot;X&quot;, value: Array(7)}\n14: {key: &quot;T&quot;, value: Array(5)}\n15: {key: &quot;E&quot;, value: Array(2)}\n16: {key: &quot;D&quot;, value: Array(1)}\n17: {key: &quot;P&quot;, value: Array(3)}\n18: {key: &quot;W&quot;, value: Array(1)}</code></pre> <pre><code class="language-js">var resultArr = []\n    for( var key in obj ){\n        resultArr.push( {\n            key:key,\n            value:obj[key]\n        } )\n    }\n    console.log( resultArr )</code></pre> <p>3》、数组对象排序 </p> <pre><code class="language-js">resultArr.sort(function( a,b ){\n    return a.key &gt; b.key ? 1:-1\n    })\n    console.log( resultArr )</code></pre> <p>4》、页面渲染</p> <pre><code class="language-js"> //  创建一个函数确定导入的内容    ( 由于不同的首字母列表对应的城市个数不同，因此需要利用利用数组遍历的方式来进行导入 )\n        function change( temp ){\n            var str1 = &#39;&#39;\n            for( var i = 0 ; i &lt; temp.length ; i++ ){\n                str1 += `&lt;li&gt;${temp[i]}&lt;/li&gt;`\n            }\n            return str1\n        }\n// 将数据渲染到页面\n    var str = &#39;&#39;\n    for( var j = 0 ; j &lt; resultArr.length ; j++ ){\n        var temp = resultArr[j].value\n        change( temp )\n        str += `&lt;P class=&quot;one&quot;&gt;${resultArr[j].key}&lt;/P&gt;\n    &lt;ul class=&quot;oneList&quot;&gt;\n    ${change(temp)}\n    &lt;/ul&gt;`\n    }\n    document.querySelector( &#39;.mianCont&#39; ).innerHTML = str</code></pre> '},fdc8:function(t,e){t.exports='<h3 id="动态路由理解">动态路由理解</h3> <h5 id="一、通过配置动态路由进行页面跳转同时进行参数传递">一、通过配置动态路由进行页面跳转同时进行参数传递</h5> <p>1、配置路由</p> <pre><code class="language-js">import Vue from &quot;vue&quot;\nimport Router from &quot;vue-router&quot;\nVue.use(Router)\n\nlet routes = [\n        {\n            path:&quot;&quot;,\n            redirect: &quot;/home&quot;\n        },\n        {\n            path:&quot;/home&quot;,\n            name:&quot;Home&quot;,\n            component:() =&gt; import(&quot;@/pages/home/Index&quot;)\n        },\n        {\n            path:&quot;/me/:data&quot;,        // ----&gt;配置路由参数，注意是配置到跳转目的地，不是跳转源头\n            name:&quot;Me&quot;,\n            component:() =&gt; import(&quot;@/pages/me/Me&quot;)\n        }\n    ]\n\nexport default new Router({\n    routes\n})</code></pre> <p>2、跳转设置 ----------》注意这种方式需要在路由里进行参数设置，用于接收方获取具体的值</p> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-a9497fbead5c3a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <p>3、数据接收</p> <pre><code>在跳转目的地进行接收    this.$route.params.data  \n    // ----&gt; 注意接收方的 data 参数要与路由配置处的参数保持一致，否则获取不到参数值</code></pre><h5 id="二、通过-router-link-进行参数传递">二、通过 router-link 进行参数传递</h5> <p><img src="https://upload-images.jianshu.io/upload_images/18620107-0b12a1cbfbe92f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> '}}]);